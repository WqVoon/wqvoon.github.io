<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>finalizer 与内存泄漏与 gc tuner | Hygao Blog</title>
  
  
  <meta name="description" content="分析 1.16 版本的 Finalizer 相关源码，包括设置、执行、可能会导致的一些问题以及 gc tuner 中对该技术的应用">
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9.9/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  <script type="text/javascript" src="/js/FunnyTitle.js"></script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>Hygao's Blog</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="世界那么大，我想搜搜看" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/tools/"
            
            
            id="tools">
            <i class='fas fa-bars fa-fw'></i>&nbsp;杂项
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/categories/"
            
            
            id="categories">
            <i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          Hygao Blog
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-rss fa-fw'></i>&nbsp;博文
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tools/"
                  
                  
                  id="tools">
									<i class='fas fa-bars fa-fw'></i>&nbsp;杂项
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友链
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-rss fa-fw'></i>&nbsp;博文
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tools/"
                
                
                id="tools">
								<i class='fas fa-bars fa-fw'></i>&nbsp;杂项
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/"
                
                
                id="categories">
								<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2023/07/26/golang-finalizer/">
        finalizer 与内存泄漏与 gc tuner
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="/" rel="nofollow">
        
          <i class="fas fa-user" aria-hidden="true"></i>
        
        <p>Hygao</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2023-07-26</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/Golang/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Golang</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>golang 是一门 GC 类语言，所以开发者无需关心内存管理相关的问题，因为不再被使用的内存会自动被垃圾回收器清理掉。针对 GC 管理的堆内存空间，golang 对开发者提供了 Finalizer 机制，当某部分内存被认为是无用内存时，与之关联的 Finalizer 就会被 runtime 执行。这样对开发者来说，Finalizer 就相当于是 GC 的钩子函数，可以在绑定的函数中写一些资源回收类的操作。</p>
<p>本文针对 Finalizer 的相关代码进行分析，并讨论这项技术可能导致的一些问题，由于篇幅原因，在分析代码时会只关注核心逻辑。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Finalizer 相当于是 GC 的钩子，所以它的执行流程中自然少不了 GC 的参与。具体来说，golang 采用的垃圾回收算法是标记清除算法，如果一个对象设置了 Finalizer，那么在标记阶段需要将该对象中所有指针类字段指向的内存标记为可达，因为 Finalizer 绑定的函数唯一的入参就是这个对象，那么就需要保证这个对象内部的字段都是可用的；另一方面，Finalizer 在垃圾回收的清除阶段才会被执行，对应的对象在本次垃圾回收时会重新被标记为存活，直到对应的 Finalizer 函数执行完毕后，这个对象对应的内存才会被释放（即便在这个期间有新一轮的 GC 被触发，这个用户侧不可达的对象也不会被清理，因为 Finalier 中保存有这个对象的指针，而 Finalizer 是一种 root 对象，所以扫描 Finalizer 时就会把这个对象标记为可达的）。</p>
<p>golang 的 runtime 使用一个独立的协程来串行执行所有的 Finalizer，这个协程平时处于休眠状态，GC 的清除阶段如果发现有需要执行的 Finalizer，那么会设置一个标记位（runtime.fingwake），在协程调度阶段，<code>runtime.findrunnable</code> 函数负责确保“一定会找到一个可执行的协程”，其中就会判断这个标记位，并按需将这个负责执行 Finalizer 的协程运行在当前的 M 上。</p>
<p>回到 Finalizer 本身上，它是怎么和对象关联起来的呢？golang 的内存模型中，runtime.mspan 是最细粒度的内存管理单元，每个 mspan 结构管理一块内存，这块内存被划分成多个相同规格的小内存，所以被 mspan 管理的每一块小内存都有自己的 offset（相当于是小内存数组的下标）；而 mspan 这个结构体中有一个 specials 字段，这是一个 special 结构的链表，golang 中有许多 special，Finalizer 就是其中一种。special 结构中有一个 offset 字段，这个 offset 正是前面提到的某块小内存对应的 offset。总结来说，给定一个 offset，我们能从 mspan 管理的内存中找到某块小内存，也能从 specials 链表中找到对应的 Finalizer（如果有的话），而这个小内存在用户侧的表现就是一个对象，因此这个 offset 就把某个对象和 Finalizer 联系起来了。</p>
<p>有了这些背景知识，我们就可以一起来看一下相关的代码了。</p>
<h1 id="设置与取消设置-Finalizer"><a href="#设置与取消设置-Finalizer" class="headerlink" title="设置与取消设置 Finalizer"></a>设置与取消设置 Finalizer</h1><p>golang 对开发者只暴露了 <code>runtime.SetFinalizer</code> 一个函数来操作 Finalizer，第一个参数是想要绑定 Finalier 的对象，这个参数需要是一个指针，而第二个参数则相对灵活，当它是一个符合条件的函数时，<code>runtime.SetFinalier</code> 被用于设置 Finalizer；而当第二个参数是 nil 时，该函数就被用于取消设置 Finalizer。同一个对象只能被设置一次 Finalizer，重复设置会导致 panic。下面直接来看一下关键部分的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFinalizer</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, finalizer <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 确保 obj 是指针类型，且指向堆内存空间</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	f := efaceOf(&amp;finalizer)</span><br><span class="line">	ftyp := f._type</span><br><span class="line">	<span class="keyword">if</span> ftyp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果第二个参数传了个 nil 进来，那么就调用 removefinalizer 移除掉已经存在的 Finalizer</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			removefinalizer(e.data)</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保第二个参数的类型是正确的</span></span><br><span class="line"> 	...</span><br><span class="line"></span><br><span class="line">okarg:</span><br><span class="line">	<span class="comment">// 计算 finalizer 这个函数的返回值需要多大的内存，因为在调用它时会构建一个假的栈帧，</span></span><br><span class="line">  <span class="comment">// 但是实际上这个返回值没有任何作用</span></span><br><span class="line">	nret := <span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> ft.out() &#123;</span><br><span class="line">		nret = alignUp(nret, <span class="keyword">uintptr</span>(t.align)) + <span class="keyword">uintptr</span>(t.size)</span><br><span class="line">	&#125;</span><br><span class="line">	nret = alignUp(nret, sys.PtrSize)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个协程，这个协程会在后台串行执行所有的 Finalizer</span></span><br><span class="line">	createfing()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 addfinalizer 将 obj 与 finalizer 绑定起来，仅在 obj 已经绑定过 finalizer 时返回 false，</span></span><br><span class="line">  <span class="comment">// 由于一个对象只能与一个 finalizer 绑定，所以程序会直接 panic</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !addfinalizer(e.data, (*funcval)(f.data), nret, fint, ot) &#123;</span><br><span class="line">			throw(<span class="string">"runtime.SetFinalizer: finalizer already set"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置-Finalizer"><a href="#设置-Finalizer" class="headerlink" title="设置 Finalizer"></a>设置 Finalizer</h2><p><code>runtime.SetFinalizer</code> 在验证参数合法后会调用 <code>runtime.addfinalizer</code> 来完成对象与 Finalizer 的绑定：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addfinalizer</span><span class="params">(p unsafe.Pointer, f *funcval, nret <span class="keyword">uintptr</span>, fint *_type, ot *ptrtype)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取一块内存用于保存 specialfinalizer 对象，specialfinalizeralloc 是一个 fixalloc 结构，</span></span><br><span class="line">  <span class="comment">// mheap 有很多 fixalloc，这是一个简单的带缓存的内存分配器，非并发安全所以需要加锁</span></span><br><span class="line">	lock(&amp;mheap_.speciallock)</span><br><span class="line">	s := (*specialfinalizer)(mheap_.specialfinalizeralloc.alloc())</span><br><span class="line">	unlock(&amp;mheap_.speciallock)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置内部字段，这个 fn 就是传进来的 finalizer 函数，这里是一个 funcval 结构，</span></span><br><span class="line">  <span class="comment">// 而 gc 的标记阶段会扫描这个 funcval，所以 finalizer 如果是个闭包函数，闭包捕获的变量也会存活</span></span><br><span class="line">	s.special.kind = _KindSpecialFinalizer</span><br><span class="line">	s.fn = f</span><br><span class="line">	s.nret = nret</span><br><span class="line">	s.fint = fint</span><br><span class="line">	s.ot = ot</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 special 与 p 地址对应的对象关联起来，这里虽然绑定的是 s.special，</span></span><br><span class="line">  <span class="comment">// 但是由于 special 是 specialfinalizer 结构起始的字段，所以它们实际拥有同样的地址，</span></span><br><span class="line">  <span class="comment">// 那么根据 special 就可以通过 unsafe.Pointer 强制转换回 specialfinalizer，</span></span><br><span class="line">  <span class="comment">// 后面在执行的时候就是用这个原理来根据 special 拿到的 specialfinalizer</span></span><br><span class="line">	<span class="keyword">if</span> addspecial(p, &amp;s.special) &#123;</span><br><span class="line">		<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">			base, _, _ := findObject(<span class="keyword">uintptr</span>(p), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">			mp := acquirem()</span><br><span class="line">			gcw := &amp;mp.p.ptr().gcw</span><br><span class="line">			<span class="comment">// 确保 p 对应对象内部的所有指针对象都被标记存活，因为在调用 finalier 时要用到这个对象</span></span><br><span class="line">			scanobject(base, gcw)</span><br><span class="line">			<span class="comment">// 扫描 funcval，所以如果有闭包捕获的变量也会被标记存活</span></span><br><span class="line">			scanblock(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s.fn)), sys.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">			releasem(mp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果执行到这里，那么 addspecial 返回了 false，而它只有 p 对应的对象已经绑定 Finalizer 时才会返回 false，</span></span><br><span class="line">  <span class="comment">// 所以这里返还前面 alloc 得到的内存，向 caller 返回 false，caller（SetFinalizer）会直接 panic</span></span><br><span class="line">	lock(&amp;mheap_.speciallock)</span><br><span class="line">	mheap_.specialfinalizeralloc.free(unsafe.Pointer(s))</span><br><span class="line">	unlock(&amp;mheap_.speciallock)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runtime.addspecial</code> 用于在 mspan 层面将 p 对应的内存与 special 绑定起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addspecial</span><span class="params">(p unsafe.Pointer, s *special)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 根据指针反查对应的 mspan 结构，如果 span 为 nil，那么说明 p 指向的内存不属于堆内存空间，</span></span><br><span class="line">  <span class="comment">// 不过前面 SetFinalizer 验证过这个问题，所以对于 Finalizer 而言应该不会出现 nil 的情况</span></span><br><span class="line">	span := spanOfHeap(<span class="keyword">uintptr</span>(p))</span><br><span class="line">	<span class="keyword">if</span> span == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"addspecial on invalid pointer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按需和 gc 同步，确保在当前 mspan 的 gc 清理阶段不会新增 special，</span></span><br><span class="line">  <span class="comment">// 因为 mspan 的清扫阶段会读内部的 specials 链表，找到需要执行的 special（包括 Finalier），</span></span><br><span class="line">  <span class="comment">// 而这个读操作没有加锁</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	span.ensureSwept()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 p 相对于 mspan 基地址的偏移量，我们前面提到过，这个 offset 用于将 p 与 Finalizer 联系起来</span></span><br><span class="line">	offset := <span class="keyword">uintptr</span>(p) - span.base()</span><br><span class="line">	kind := s.kind</span><br><span class="line"></span><br><span class="line">	lock(&amp;span.speciallock)</span><br><span class="line"></span><br><span class="line">	t := &amp;span.specials</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		x := *t</span><br><span class="line">		<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 如果 offset 和 kind 都相同，就说明 p 对应的地址已经绑定过 Finalier 了，</span></span><br><span class="line">    <span class="comment">// 此时向 caller 返回 false</span></span><br><span class="line">		<span class="keyword">if</span> offset == <span class="keyword">uintptr</span>(x.offset) &amp;&amp; kind == x.kind &#123;</span><br><span class="line">			unlock(&amp;span.speciallock)</span><br><span class="line">			releasem(mp)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 这个操作一方面能让 for 循环提前结束，一方面能保证 specials 链表中的元素是有序的</span></span><br><span class="line">		<span class="keyword">if</span> offset &lt; <span class="keyword">uintptr</span>(x.offset) || (offset == <span class="keyword">uintptr</span>(x.offset) &amp;&amp; kind &lt; x.kind) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		t = &amp;x.next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将新的 special 加入到链表中合适的位置，标记 mspan 有 special，这样就完成了 Finalier 的绑定操作</span></span><br><span class="line">	s.offset = <span class="keyword">uint16</span>(offset)</span><br><span class="line">	s.next = *t</span><br><span class="line">	*t = s</span><br><span class="line">	spanHasSpecials(span)</span><br><span class="line">	unlock(&amp;span.speciallock)</span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取消-Finalizer"><a href="#取消-Finalizer" class="headerlink" title="取消 Finalizer"></a>取消 Finalizer</h2><p>如果 <code>runtime.SetFinalizer</code> 的第二个参数是一个 nil，那么最终这个函数会调用 <code>runtime.removefinalizer</code>，从而解除对象与其 Finalizer 的绑定关系，与设置 Finalizer 不同，取消绑定这一操作是幂等的，重复调用也不会导致程序 panic。下面一起来看下 <code>runtime.removefinalizer</code> 的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removefinalizer</span><span class="params">(p unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 调用 removespecial 来移除 _KindSpecialFinalizer 类型的 special，其实就是 Finalizer</span></span><br><span class="line">	s := (*specialfinalizer)(unsafe.Pointer(removespecial(p, _KindSpecialFinalizer)))</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 如果没找到与对象绑定的 Finalizer 就直接返回，这里就是幂等的</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里的 free 并没有将内存还给操作系统，而是将其缓存起来方便下次 alloc 时复用</span></span><br><span class="line">	lock(&amp;mheap_.speciallock)</span><br><span class="line">	mheap_.specialfinalizeralloc.free(unsafe.Pointer(s))</span><br><span class="line">	unlock(&amp;mheap_.speciallock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>runtime.addspecial</code>相反 ， <code>runtime.removespecial</code> 的作用是在 mspan 层面将 p 对应的内存与已经存在的 special 解绑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removespecial</span><span class="params">(p unsafe.Pointer, kind <span class="keyword">uint8</span>)</span> *<span class="title">special</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取 p 内存所在的 mspan 结构体</span></span><br><span class="line">	span := spanOfHeap(<span class="keyword">uintptr</span>(p))</span><br><span class="line">	<span class="keyword">if</span> span == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"removespecial on invalid pointer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 和 addspecial 一样，这里也需要确保当前 mspan 的 GC 的清扫已经完成</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	span.ensureSwept()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算 offset，这个 offset 用于寻找对应的 Finalizer</span></span><br><span class="line">	offset := <span class="keyword">uintptr</span>(p) - span.base()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result *special</span><br><span class="line">	lock(&amp;span.speciallock)</span><br><span class="line">	t := &amp;span.specials</span><br><span class="line">  <span class="comment">// 遍历 specials 链表，找到 offset 对应的 Finalizer，</span></span><br><span class="line">  <span class="comment">// 但是其实 special 结构是按 offset 排序的，所以这里可以不完全遍历整条链表</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		s := *t</span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> offset == <span class="keyword">uintptr</span>(s.offset) &amp;&amp; kind == s.kind &#123;</span><br><span class="line">			*t = s.next</span><br><span class="line">			result = s</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		t = &amp;s.next</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果当前的 mspan 已经没有 specials 了，那么就调用 spanHasNoSpecials 标记它</span></span><br><span class="line">	<span class="keyword">if</span> span.specials == <span class="literal">nil</span> &#123;</span><br><span class="line">		spanHasNoSpecials(span)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;span.speciallock)</span><br><span class="line">	releasem(mp)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回找到的结果，或者如果没找到就返回一个 nil</span></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行-Finalizer"><a href="#执行-Finalizer" class="headerlink" title="执行 Finalizer"></a>执行 Finalizer</h1><p>在 <code>runtime.SetFinalizer</code> 中，如果尝试给某个对象绑定 Finalizer，那么流程中会走到 <code>runtime.createfing</code> 函数，这个函数的内容是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createfing</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过全局的 fingCreate 函数来确保 if 块中的逻辑只被执行一次</span></span><br><span class="line">	<span class="keyword">if</span> fingCreate == <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;fingCreate, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">go</span> runfinq()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>runtime.runfinq</code> 是被另一个 gouroutine 来执行的，这就是我们说的那个会负责串行执行所有 Finalizer 函数的 goroutine，我们来重点看它前半部的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runfinq</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 先不管这两个变量，这是执行 Finalizer 时才会用到的，用于构造假的栈帧</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		frame    unsafe.Pointer</span><br><span class="line">		framecap <span class="keyword">uintptr</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 整个函数是一个永不停止的 for 循环</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 下面这些 finq、fing 都是全局变量，而 finlock 用于确保这些全局变量变更时的原子性</span></span><br><span class="line">		lock(&amp;finlock)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前 finq 中的内容，finq 中会保存所有的待执行 Finalizer 函数，</span></span><br><span class="line">    <span class="comment">// 这个变量的赋值逻辑我们后面会提到</span></span><br><span class="line">		fb := finq</span><br><span class="line">		finq = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前没有待执行的 Finalizer，陷入休眠</span></span><br><span class="line">		<span class="keyword">if</span> fb == <span class="literal">nil</span> &#123;</span><br><span class="line">			gp := getg()</span><br><span class="line">			fing = gp</span><br><span class="line">      <span class="comment">// 设置 fingwait，代表当前有负责执行 Finalizer 的 goroutine 在等待被调度执行</span></span><br><span class="line">			fingwait = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 调用 gopark 将当前 goroutine 挂起，当前的 m 会去执行其他的 goroutine</span></span><br><span class="line">			goparkunlock(&amp;finlock, waitReasonFinalizerWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;finlock)</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 执行 fb 中所有的 Finalizer</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，fing 这个 goroutine 一直在一个永不停止的 for 循环中打转，每次循环时尝试从 finq 中拿到待执行的 Finalizer 并去执行它们，而如果 finq 是空的，那么就设置 fingwait 并将 fing 挂起。不难想到，只有 finq 中有内容后才应该唤醒 fing，否则就没有任何意义。所以现在我们就需要关注两个点，第一是 finq 中什么时候有内容，第二是如何唤醒 fing。</p>
<p>先来看什么时候有内容，GC 的清理阶段最终会落实到每一个 msapn 上，具体来说是会调用到 <code>mspan.sweep</code> 这个方法。在这个方法中有这样一段逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">sweep</span><span class="params">(preserve <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mspan 中保存的小内存块大小</span></span><br><span class="line">  size := s.elemsize</span><br><span class="line"></span><br><span class="line">	hadSpecials := s.specials != <span class="literal">nil</span></span><br><span class="line">	specialp := &amp;s.specials</span><br><span class="line">	special := *specialp</span><br><span class="line">	<span class="keyword">for</span> special != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 offset 对应对象在 mspan 中的下标，因为比如对于 struct&#123;a, b int&#125; 这样的对象而言，</span></span><br><span class="line">    <span class="comment">// a 和 b 均可以设置 Finalizer，但是整个 struct 在 GC 的清扫阶段是被看作一个整体的，</span></span><br><span class="line">    <span class="comment">// 所以内部字段绑定的 Finalizer 均会被执行，然后需要把整个 struct 标记为存活（这需要知道下标），</span></span><br><span class="line">    <span class="comment">// 通过整数除法的方式可以根据 a 和 b 的地址获取整个 struct 在 mspan 中的下标</span></span><br><span class="line">		objIndex := <span class="keyword">uintptr</span>(special.offset) / size</span><br><span class="line">		p := s.base() + objIndex*size</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据对象的下标获取对应的标记位图</span></span><br><span class="line">		mbits := s.markBitsForIndex(objIndex)</span><br><span class="line">    <span class="comment">// 如果没有标记，说明这个对象在用户侧没有来自 root 对象的引用，在没有 Finalizer 的情况下应该被删除</span></span><br><span class="line">		<span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line">			hasFin := <span class="literal">false</span></span><br><span class="line">			endOffset := p - s.base() + size</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// special 是根据 offset 从小到大排序的，所以可以把 endOffset 作为循环结束条件</span></span><br><span class="line">			<span class="keyword">for</span> tmp := special; tmp != <span class="literal">nil</span> &amp;&amp; <span class="keyword">uintptr</span>(tmp.offset) &lt; endOffset; tmp = tmp.next &#123;</span><br><span class="line">				<span class="keyword">if</span> tmp.kind == _KindSpecialFinalizer &#123;</span><br><span class="line">					<span class="comment">// 发现对象有 Finalizer，需要将对应的对象标记存活，让它至少再活一轮 GC</span></span><br><span class="line">					mbits.setMarkedNonAtomic()</span><br><span class="line">					hasFin = <span class="literal">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> special != <span class="literal">nil</span> &amp;&amp; <span class="keyword">uintptr</span>(special.offset) &lt; endOffset &#123;</span><br><span class="line">				p := s.base() + <span class="keyword">uintptr</span>(special.offset)</span><br><span class="line">				<span class="keyword">if</span> special.kind == _KindSpecialFinalizer || !hasFin &#123;</span><br><span class="line">          <span class="comment">// 从链表中删除这个 special，然后把相关信息传递给 freespecial，</span></span><br><span class="line">          <span class="comment">// 这个 freespecial 就是将 Finalizer 放到 finq 中的关键函数</span></span><br><span class="line">					y := special</span><br><span class="line">					special = special.next</span><br><span class="line">					*specialp = special</span><br><span class="line">					freespecial(y, unsafe.Pointer(p), size)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					specialp = &amp;special.next</span><br><span class="line">					special = *specialp</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 被标记了，说明对象经历了这轮 GC 后依然存活，所以不需要执行 Finalizer</span></span><br><span class="line">			specialp = &amp;special.next</span><br><span class="line">			special = *specialp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 如果之前当前 mspan 有 special 但经历了上面的循环后没有 special，</span></span><br><span class="line">  <span class="comment">// 那么调用 spanHasNoSpecials 标记</span></span><br><span class="line">	<span class="keyword">if</span> hadSpecials &amp;&amp; s.specials == <span class="literal">nil</span> &#123;</span><br><span class="line">		spanHasNoSpecials(s)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从链表上取下来的 Finalizer 会被送到 <code>runtime.freespecial</code> 这个函数中，事实上其他的 special 也在这里被处理，不过我们只关注 Finalizer 的部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freespecial</span><span class="params">(s *special, p unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> s.kind &#123;</span><br><span class="line">	<span class="keyword">case</span> _KindSpecialFinalizer:</span><br><span class="line">    <span class="comment">// 这里印证了前面的结论，虽然入参的 s 是一个 special，但实际它是 specialfinalizer 的一部分，</span></span><br><span class="line">    <span class="comment">// 且是它的第一个字段，所以两者拥有相同的地址，可以通过 unsafe.Pointer 强转，</span></span><br><span class="line">    <span class="comment">// golang 虽然不希望对使用者暴露太多指针的概念，但这种强转确实好用且高效，</span></span><br><span class="line">    <span class="comment">// 这也是在 c 语言中实现多态的有效手段</span></span><br><span class="line">		sf := (*specialfinalizer)(unsafe.Pointer(s))</span><br><span class="line">    <span class="comment">// 使用转换出来的 specialfinalizer 结构调用 queuefinalizer 函数</span></span><br><span class="line">		queuefinalizer(p, sf.fn, sf.nret, sf.fint, sf.ot)</span><br><span class="line">    <span class="comment">// 调用结束后，“回收” specialfinalizer 对应的内存，fixalloc 会将其缓存方便下次使用</span></span><br><span class="line">		lock(&amp;mheap_.speciallock)</span><br><span class="line">		mheap_.specialfinalizeralloc.free(unsafe.Pointer(sf))</span><br><span class="line">		unlock(&amp;mheap_.speciallock)</span><br><span class="line">	</span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		throw(<span class="string">"bad special kind"</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"not reached"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runtime.freespecial</code> 根据 kind 字段的取值把入参的 special 结构转换成具体的 special 然后分别处理，针对 Finalizer 就是调用 <code>runtime.queuefinalizer</code> 函数，这个函数的逻辑是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queuefinalizer</span><span class="params">(p unsafe.Pointer, fn *funcval, nret <span class="keyword">uintptr</span>, fint *_type, ot *ptrtype)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">    <span class="comment">// GC 的清扫阶段对应的 gcPhase 是 GCoff，需要确保状态是对的</span></span><br><span class="line">		throw(<span class="string">"queuefinalizer during GC"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面反正就是往 finq 里塞东西，有个 finc 是缓存 finblock 结构用的，</span></span><br><span class="line">  <span class="comment">// 设计思路类似于 fixalloc，把上层认为可以回收的内存缓存起来给下次用</span></span><br><span class="line">	lock(&amp;finlock)</span><br><span class="line">	<span class="keyword">if</span> finq == <span class="literal">nil</span> || finq.cnt == <span class="keyword">uint32</span>(<span class="built_in">len</span>(finq.fin)) &#123;</span><br><span class="line">		<span class="keyword">if</span> finc == <span class="literal">nil</span> &#123;</span><br><span class="line">			finc = (*finblock)(persistentalloc(_FinBlockSize, <span class="number">0</span>, &amp;memstats.gcMiscSys))</span><br><span class="line">			finc.alllink = allfin</span><br><span class="line">			allfin = finc</span><br><span class="line">			<span class="keyword">if</span> finptrmask[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (unsafe.Sizeof(finalizer&#123;&#125;) != <span class="number">5</span>*sys.PtrSize ||</span><br><span class="line">					unsafe.Offsetof(finalizer&#123;&#125;.fn) != <span class="number">0</span> ||</span><br><span class="line">					unsafe.Offsetof(finalizer&#123;&#125;.arg) != sys.PtrSize ||</span><br><span class="line">					unsafe.Offsetof(finalizer&#123;&#125;.nret) != <span class="number">2</span>*sys.PtrSize ||</span><br><span class="line">					unsafe.Offsetof(finalizer&#123;&#125;.fint) != <span class="number">3</span>*sys.PtrSize ||</span><br><span class="line">					unsafe.Offsetof(finalizer&#123;&#125;.ot) != <span class="number">4</span>*sys.PtrSize) &#123;</span><br><span class="line">					throw(<span class="string">"finalizer out of sync"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> i := <span class="keyword">range</span> finptrmask &#123;</span><br><span class="line">					finptrmask[i] = finalizer1[i%<span class="built_in">len</span>(finalizer1)]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		block := finc</span><br><span class="line">		finc = block.next</span><br><span class="line">		block.next = finq</span><br><span class="line">		finq = block</span><br><span class="line">	&#125;</span><br><span class="line">	f := &amp;finq.fin[finq.cnt]</span><br><span class="line">	atomic.Xadd(&amp;finq.cnt, +<span class="number">1</span>)</span><br><span class="line">	f.fn = fn</span><br><span class="line">	f.nret = nret</span><br><span class="line">	f.fint = fint</span><br><span class="line">	f.ot = ot</span><br><span class="line">	f.arg = p</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意这里设置了 fingwake 这个全局变量的值</span></span><br><span class="line">	fingwake = <span class="literal">true</span></span><br><span class="line">	unlock(&amp;finlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说，GC 的清扫阶段将各个 mspan 上的 Finalizer 塞进了 finq 结构，这样当 fing 协程被唤醒时就可以顺利地从 finq 中获取到待执行的 Finalizer 并串行执行它们。那么现在剩下的唯一问题就是如何唤醒 fing 了，在前面分析 fing 的代码时我们看到它在陷入休眠前设置了 fingwait 这个变量，现在 <code>runtime.queuefinalizer</code> 又设置了 fingwake，现在就需要有一个地方能感知到这两个变量的变化并做实际的唤醒操作。不难想到，这应该是调度器做的事情，具体来说，<code>runtime.findrunnable</code> 会接下这个任务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 fingwait 为 true 且 fingwake 也为 true，那么就调用 wakgfing，</span></span><br><span class="line">  <span class="comment">// 如果能获取到对应的 g 的指针（其实就是全局变量 fing），那么就调用 runtime.ready，</span></span><br><span class="line">  <span class="comment">// 将对应的 g 放到调度队列中等待 m 来执行它</span></span><br><span class="line">	<span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">		<span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakefing</span><span class="params">()</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">  <span class="comment">// 可以看到，其实就是把 fing 返回出去了</span></span><br><span class="line">	<span class="keyword">var</span> res *g</span><br><span class="line">	lock(&amp;finlock)</span><br><span class="line">	<span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">		fingwait = <span class="literal">false</span></span><br><span class="line">		fingwake = <span class="literal">false</span></span><br><span class="line">		res = fing</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;finlock)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Finalizer-的一些问题"><a href="#Finalizer-的一些问题" class="headerlink" title="Finalizer 的一些问题"></a>Finalizer 的一些问题</h1><h2 id="长耗时操作导致其他对象的-Finalizer-无法被执行"><a href="#长耗时操作导致其他对象的-Finalizer-无法被执行" class="headerlink" title="长耗时操作导致其他对象的 Finalizer 无法被执行"></a>长耗时操作导致其他对象的 Finalizer 无法被执行</h2><p>我们在上面分析了 Finalizer 的执行过程，可以看到只有一个 fing 在后台默默地串行执行所有的 Finalizer，所以如果有一个 Finalizer 的逻辑耗时很长，那么后面的 Finalizer 就只能等待，而即便这期间有新一轮的 GC 被执行，后面 Finalizer 绑定的对象也无法被清理，因为 Finalizer 函数的入参就是这个对象，需要保证在执行时这个对象是可用的。所以如果这个对象占用了大量的内存，那么在对应的 Finalizer 被执行前，它占用的内存就无法被释放。为了避免这种情况导致的“内存泄露”， <code>runtime.SetFinalizer</code> 的注释中也提到，如果有这种长耗时的 Finalizer，最好在内部创建一个新的 goroutine 来完成这部分逻辑。</p>
<p>下面是一个例子，尽管我们每秒主动触发一次 GC 操作，但 b 对象仍然要等绑定的 Finalizer 执行完毕后才能被释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line">	&#123;</span><br><span class="line">    <span class="comment">// 为 a 设置一个长耗时的 Finalizer</span></span><br><span class="line">		runtime.SetFinalizer(&amp;a, <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"start to exec a finalizer"</span>)</span><br><span class="line">			time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">			fmt.Println(<span class="string">"a finalizer finished"</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">    <span class="comment">// 虽然 b 的 Finalizer 耗时很短，但它需要等 a 执行完毕</span></span><br><span class="line">		runtime.SetFinalizer(&amp;b, <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"start to exec b finalizer"</span>)</span><br><span class="line">			fmt.Println(<span class="string">"b finalizer finished"</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> time.NewTicker(time.Second).C &#123;</span><br><span class="line">		fmt.Println(<span class="string">"call runtime.GC()"</span>)</span><br><span class="line">		runtime.GC()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> go run -gcflags <span class="string">'-N -l'</span> .</span></span><br><span class="line">call runtime.GC()</span><br><span class="line">start to exec a finalizer</span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br><span class="line">a finalizer finished</span><br><span class="line">start to exec b finalizer</span><br><span class="line">b finalizer finished</span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br></pre></td></tr></table></figure>

<h2 id="循环引用导致内存泄漏"><a href="#循环引用导致内存泄漏" class="headerlink" title="循环引用导致内存泄漏"></a>循环引用导致内存泄漏</h2><p>如果有一个对象绑定了 Finalizer，那么这个对象本身及其内部字段都要持续存活，直到对应的 Finalizer 执行完毕。如果我们构建了一个循环引用，a 是 b 的内部字段，b 是 a 的内部字段，且 a 和 b 都设置了 Finalizer，那么 b 会因为 a 的 Finalizer 而持续存活，a 会因为 b 的 Finalizer 而持续存活。这样一来，尽管用户侧已经没有了对 a 和 b 的引用，但由于前面循环引用的存在，a 和 b 都无法被释放。</p>
<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">		ptr *T</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建循环引用</span></span><br><span class="line">	a := &amp;T&#123;&#125;</span><br><span class="line">	b := &amp;T&#123;ptr: a&#125;</span><br><span class="line">	a.ptr = b <span class="comment">// 如果把这行注释掉，就不会循环引用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 runtime.SetFinalizer</span></span><br><span class="line">	&#123;</span><br><span class="line">		runtime.SetFinalizer(a, <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"a finalizer"</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">		runtime.SetFinalizer(b, <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"b finalizer"</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  a, b = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> time.NewTicker(time.Second).C &#123;</span><br><span class="line">		fmt.Println(<span class="string">"call runtime.GC()"</span>)</span><br><span class="line">		runtime.GC()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> go run -gcflags <span class="string">'-N -l'</span> .</span></span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="GC-Tuner-对-Finalizer-的应用"><a href="#GC-Tuner-对-Finalizer-的应用" class="headerlink" title="GC Tuner 对 Finalizer 的应用"></a>GC Tuner 对 Finalizer 的应用</h1><p>GC Tuner 是 uber 提出的一种针对 GC 的优化手段，其原理是在每次 GC 被触发时动态调整 GOGC 的取值，从而保证内存一直维持在一个比较恒定的水位，最终达到空间换时间的效果，避免 GC 的频繁发生。在这个过程中有两个核心的操作，第一是我们需要在每次 GC 到来时都执行一段自定义逻辑，第二是这段自定义逻辑用来调整 GOGC 的取值。</p>
<p>经过前面的分析，不难想到这里的第一点可以用 Finalizer 技术来实现。具体来说，对一个对象设置了 Finalizer 后，当 GC 到达清扫阶段后会执行绑定的函数，函数执行结束后才会释放对象对应的内存。那么如果我们在绑定的函数中再次为这个对象设置 Finalizer，就可以保证这个对象持续存活到下一次绑定函数被执行。通过这种递归的方式，就可以确保对象一直存活，而 Finalizer 函数不断地被 GC 清扫阶段触发，而这恰好符合 GC Tuner 的目标。</p>
<p>但需要注意的是，其他对象绑定的 Finalizer 不能包含长耗时的操作，否则就会遇到我们前面提到过的问题，可能会有几轮 GC 脱离了 GC Tuner 的控制。</p>
<p>下面是一个例子，对象 a 绑定的 Finalizer 函数会因为 GC 的触发而不断被调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		a         <span class="keyword">int</span></span><br><span class="line">		finalFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function">	<span class="title">finalFunc</span> = <span class="title">func</span><span class="params">(ap <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"can u see me?"</span>)</span><br><span class="line">		runtime.SetFinalizer(ap, finalFunc)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime.SetFinalizer(&amp;a, finalFunc)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> time.NewTicker(time.Second).C &#123;</span><br><span class="line">		fmt.Println(<span class="string">"call runtime.GC()"</span>)</span><br><span class="line">		runtime.GC()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">go</span> run -gcflags <span class="string">'-N -l'</span> .</span><br><span class="line">call runtime.GC()</span><br><span class="line">call runtime.GC()</span><br><span class="line">can u see me?</span><br><span class="line">call runtime.GC()</span><br><span class="line">can u see me?</span><br><span class="line">call runtime.GC()</span><br><span class="line">can u see me?</span><br><span class="line">call runtime.GC()</span><br><span class="line">can u see me?</span><br><span class="line">call runtime.GC()</span><br><span class="line">can u see me?</span><br><span class="line">call runtime.GC()</span><br><span class="line">can u see me?</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


      </div>
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2023-12-31T02:04:50+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>更新于 2023年12月31日</p>
  </a>
</div>

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=/2023/07/26/golang-finalizer/&title=finalizer 与内存泄漏与 gc tuner | Hygao Blog&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=/2023/07/26/golang-finalizer/&title=finalizer 与内存泄漏与 gc tuner | Hygao Blog&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=/2023/07/26/golang-finalizer/&title=finalizer 与内存泄漏与 gc tuner | Hygao Blog&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
                  <section class="prev">
                      <span class="art-item-left">
                          <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                          <h4>
                              <a href="/2023/10/08/golang-requests/" rel="prev" title="golang requests 源码解读">
                                
                                    golang requests 源码解读
                                
                              </a>
                          </h4>
                          
                      </span>
                  </section>
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/2023/07/01/golang-sync-package-v2/" rel="prev" title="sync 标准库部分内容源码解读">
                                  
                                      sync 标准库部分内容源码解读
                                  
                              </a>
                          </h4>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'finalizer 与内存泄漏与 gc tuner',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='/images/avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:2027195958@qq.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/wqvoon"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=1731490938"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/CTF/" href="/categories/CTF/"><div class='name'>CTF</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Docker/" href="/categories/Docker/"><div class='name'>Docker</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Golang/" href="/categories/Golang/"><div class='name'>Golang</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box" title="/categories/分布式/" href="/categories/分布式/"><div class='name'>分布式</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box" title="/categories/前端/" href="/categories/前端/"><div class='name'>前端</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box" title="/categories/存储/" href="/categories/存储/"><div class='name'>存储</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/杂项/" href="/categories/杂项/"><div class='name'>杂项</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/网络/" href="/categories/网络/"><div class='name'>网络</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/论文/" href="/categories/论文/"><div class='name'>论文</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box" title="/categories/设计模式/" href="/categories/设计模式/"><div class='name'>设计模式</div><div class='badge'>(2)</div></a></li>
        
      </ul>
    </div>
  </section>


            
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              

            
          
        
      
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:2027195958@qq.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/wqvoon"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=1731490938"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
